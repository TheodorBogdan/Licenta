\documentclass[a4paper,12pt]{report}
    \title{Service Registry}
\author{Theodor Bogdan Vr\^ancean}
\date {Iunie 2018}

\usepackage[romanian]{babel}

\usepackage{graphicx}
\graphicspath{{"./Images/"}}

\usepackage{parskip}
\usepackage{indentfirst}
\setlength{\parindent}{1cm}
\usepackage{listings}
\usepackage{csquotes}
\usepackage[
    backend=biber,
    style=verbose,
	sorting=ynt,
	maxbibnames=99,
	maxcitenames=6
]{biblatex}

\addbibresource{References.bib}
%Rejne / Sonny
\usepackage[Sonny]{fncychap}
\iffalse
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}
\fi

\let\oldref\ref
\renewcommand{\ref}[1]{[\oldref{#1}]}

\lstset{
	frame=single
}

\begin{document}
\maketitle
\tableofcontents
\chapter{Introducere}
\section{Arhitectura de microservicii}

Arhitectura de microservicii este o abrodare relativ nou\u a \^ in dezvoltarea de software.
Microserviciile reprezint\u a aplica\c tii mici \c si autonome care lucreaz\u a \^ impreun\u a
\footcite{buildingMicroservices1}. Ele sunt considerate mici relativ la un sistem monolitic care ar
oferi toate func\c tionalit\u a\c tiile de care aplica\c tia are nevoie.Cu toate acestea un mictoserviciu poate oferi orice
fel de func\c tionalit\u a\c ti,incep\^and cu ceva simplu precum desc\u arcarea de fi\c siere, p\^an\u a la
complexe precum analizarea imaginilor.
Aceast\u a aboradare arhitecturala a venit ca o alternativ\u a la arhitectura monolitic\u a, \^in care exist\u a
un singur server care satisface toate necesit\u a\c tile unei aplica\c tii.Limit\u arile acestei abord\u ari ies la iveal\u a
odat\u a cu cre\c sterea aplica\c tiei.
Pentru a \^intelege de ce arhitectura  de microservicii \^incepe sa \^inlocuiasc\u a arhitectura monolitic\u a
trebuie sa cunoa\c stem urm\u atoarele beneficii:
\begin{itemize}
	\item Din cauza dimensiunii \c si complexit\u a\c tii unui proiect monolitic,
	      acesta este dificil de in\c teles \c ,motiv pentru care schimb\u arile sunt mai dificil de facut \c si exist\u a
	      un risc mai mare ca acestea s\u a produc\u a efecte nedorite.Aceste probleme pot fi atenuate printr-un
	      cod de calitate dar acest lucru se \^ inatmpla de prea pu\c tine ori. Schimb\u arile aduse unui microserviciu nu afecteaz\u a alte
	      module \c si datorit\u a dimensiunii reduse a acestora, ele sunt \c si mai u\c sor de \^inteles pentru programtori, astfel
	      scade probabilitatea erorilor.Se poate spune ca microserviciile duc un pas mai departe principiul singurei responsabilit\u a\c ti,
	      definit de Robert C. Martin.
	\item Pentru dezvoltarea unei aplica\c tii monolitice trebuie sa alegem tehnologii standardizate care s\u a poata
	      realiza toate cerin\c tele aplica\c tiei. Pe de alta parte,daca avem mai multe microservicii care colaboreaz\u a nu exist\u a
	      aceast\u a limitare,ceea ne permite s\u a alegem unealta cea mai portivit\u a pentru fiecare serviciu.
	      S\u a lu\u am spre exemplu un site al unei pizzerii care folose\c ste microservicii (Fig 1).
	      Partea de front-end doar apeleaz\u a serviciile c\^and are nevoie.Putem avea un server scris
	      in C\# care folose\c ste un sistem de gestiune a bazei de date Microsoft Sql Server,
	      unul scris \^in php cu MySql \c si unul scris in Node.js cu mongoDb \ref{fig:PizzaMicroservicii}.Deoarce toate comunic\u a prin
	      protocolul http ,acestea pot lucra \^impreun\u a,fiecare av\^and responsabilitatea sa.
	      \begin{figure}[!htb]
		      \includegraphics[width=\textwidth,keepaspectratio]{PizzaMicroservicii}
		      \caption{Arhitectur\u a cu microservicii pentru un site de pizzerie}
		      \label{fig:PizzaMicroservicii}
	      \end{figure}
	\item O aplica\c tie a c\u arei componente sunt distribuite este mai rezistent\u a, \^in sensul c\u a dac\u a un
	      serviciu este compromis, func\c tionalita\c tile care nu depind de acel serviciu vor continua s\u a func\c tioneze.
	      \^In cazul unei aplica\c tii clasice, tot sistemul va fi compromis din cauza unei singure componente.
	\item Cu un serviciu mare,monolitic, trebuie sa scal\u am totul \^imreun\u a.O parte mic\u a
	      a \^intregului nostru sistem, este constr\^ans\u a \^in performan\c t\u a, dar dac\u a
	      acest comportament este blocat \^intr-o aplica\c tie monolitic\u a gigant\u a, trebuie sa scal\u am totul \^impreun\u a
	      ca o bucat\u a \footcite{buildingMicroservices5}.Acest lucru se face deobicei folosind mai multe servere
	      \c si un server de tip load balancer care s\u a distribuie cererile c\u atre unul din acele servere pentru
	      a reduce munca depus\u a de un singur server o depune, astfel evit\^and supra\^incarcarea si cresc\^and performan\c ta.
	      \^In cazul arhitecturii cu microservicii, ajunge s\u a scalam doar acele servicii care au probleme de performan\c ta.
	\item Microserviciile ofer\u a \c si reutilizabiliate, ele pot fi utilizate de multiple aplica\c tii.
		  Daca dou\u a aplica\c tii au func\c tionalita\c ti similare, acestea nu trebuie implementate de dou\u a ori, aceast\u a func\c tionalitate
		  poate fi oferit\u a de un serviciu comun , folosit de ambele aplica\c tii.Uneori acest lucru este chiar necesar, dac\u a un produc\u ator de software
		  are mai multe aplica\c tii ce necesit\u a autentificare, este mult mai comod pentru utilizator s\u a aib\u a un singur cont cu care s\u a se autentifice in fiecare aplica\c tie 
		  \c si acest lucru este avantajos si pentru produc\u ator.
		  Microserviciile pot fi f\u acute \c si publice, pe baza unei chei de autentificare,pe care le pot folosi pentru aplica\c tiile lor,persoane in afara companiei produc\u atoare.
		  \^In prezent exist\u a multe servicii de meteorologie, gratuite sau contra cost, pe care le putem folosi \^in aplica\c tiile noastre.
\end{itemize}

Bine\^in\c teles arhitectura cu microservicii nu este o solu\c tie miraculoas\u a la toate problemele,
adat\u a cu aceste beneficii, ea vine \c si cu dezavantajele.Fiind un sistem distribuit toate
problemele acestor sisteme afecteaz\u a si microservicii.
O problem\u a este men\c tinerea leg\u aturii \^intre componentele aplica\c tiei.Un serviciu \^isi poate schimba 
adresa,poate deveni inactiv sau poate fi \^inlocuit.\^In aceste situa\c tii se va pierde func\c tionalitatea pe care acesta o 
ofer\u a.Pentru a remedia aceast\u a situa\c tie ar trebui sa schimb\u am adresele la care aplica\c tia se a\c steapt\u a sa 
gaseasc\u a serviciul respectiv, dup\u a care ar trebui sa to\c ti utilizatorii sa sa fac\u a un update la noua versiune.
Aceast\u a solu\c tie simpl\u a nu doar c\u a nu este convenabil\u a ,dar devine imposibil\u a dac\u a avem servicii care ruleaz\u a 
pe ma\c sini virtuale sau containere de docker care suntcreate dinamic \^in func\c tie de nevoie.
\section{Serviciu de \^inregistrare}
Solu\c tia pe care eu am implementat-o este un sistem de tip service registry.
Acesta este la baz\u a un serviciu web care face leg\u atura \^intre microservicii.Astfel aplica\c tia \c si serviciile trebuie 
s\u a cunoasc\u a doar serviciul de \^inregistrare si el se va furniza datele despre celelalte servicii necesare func\c tionarii aplica\c tiei. 
Serverul de \^ inregistrare ofer\u a trei opera\c tii de baza:
\begin{enumerate}
	\item \textbf{\^Inregistrarea}
	
			Serviciile se pot \^inregistra la server atunci c\^and \^i\c si \^incep func\c tionarea.
			\^In cazul \^in care serviciu folosit este facut de un alt produc\u ator care nu cunoa\c ste acest 
			mecanism sau nu este dispus s\u a \^il foloseasc\u a,exist\u a \c si posibilitatea ca administratorul 
			aplica\c tiei sa \^inregistreze serviciul respectiv manual prin intermediul intefer\c tei grafice.
	\item \textbf{De\^inregistrarea}

		  Serviciile au posibilitatea de a se de\^inregistra,acest lucru ar trebuie s\u a fie f\u acut la \^inchiderea 
		  serviciului.\^In cazul in care acestea devin inactive far\u a a se de\^inregistra, serverul le va de\^inregistra
		  automat.
	\item \textbf{C\u autarea}

		  Aplica\c tia \c si microserviciile pot c\u auta un serviciu \^inregistrat \^in server.
\end{enumerate}	
\section{Extensibilitate}
Extensibilitatea este o problem\u a permanent\u a \^in dezvoltarea de software.Un program poate \c si deobicei 
trebuie dezvoltat continuu.Serviciu de \^inregistrare, din cauza rolulului pe care \^il are, nu ar trebui oprit 
pentru actuazliz\u ari doar dac\u a acestea sunt absolut necesare \c si acest lucru trebuie s\u a se \^intample
c\^at mai rar posibil.\^In acest sens am implementat un mecanism de extensibilitate care nu necesit\u a oprirea
serverului.Aplica\c tia poate fi extins\u a prin add-inuri.Din acest motiv am expus un API pe care \^il pot folosi 
pentru dezvoltarea acestor add-inuri.Bine\^inteles, schimb\u arile mai importante nu pot fi f\u acute prin add-inuri
dar acestea reprezint\u a un mecanism suficient de bun pentru a ad\u auga func\c tionalit\u ati aplica\c tiei far\u a
a \^intrerupe fun\c tionarea serverului.Un alt avantaj al acestei abord\u ari const\u a \^in posibilitatea de 
ad\u augare de func\c tionalit\u ati la aplica\c tie de c\u atre utilizator. Acesta poate face un add-in 
folsind API-ul pe care \^il pun la dispozi\c tie.
Am ales s\u a ofer trei tipuri de add-inuri:
\begin{enumerate}
		\item \textbf{Add-In ac\c tiune}

			Acesta poate fi declan\c sat de c\u atre utilizator prin interfa\c ta grafic\u a.
		\item \textbf{Add-In periodic}

			Acest tip de add-in se execut\u a la un interval de timp.
		\item \textbf{Add-In pentru echilibrarea \^inc\u arc\u aturii}
		
			Acesta este un add-in special care con\c tine implementarea unui algoritm de echilibrare a \^inc\u arc\u aturii.
			\^In aplica\c tie poate exista un singur add-in pentru echilibrarea \^inc\u arc\u aturii.\^In cazul \^in care
			programul g\u ase\c ste mai multe astfel de add-inuri, este selectat aleator unul dintre ele.
\end{enumerate}

\section{Load Balancer}

Aplica\c tia mea, fiind un serviciu de \^inregistrare trebuie s\u a ia \^in calcul posibilitatea de a avea mai multe servicii
\^inregistrate cu acela\c si nume.Acest lucru poate p\u area c\u a ar trebui interzis \^ins\u a eu am ales s\u a accept \c si 
chiar s\u a \^incurajez aceast\u a situa\c tie.Cu acest scop am ad\u augat func\c tionalitatea de load balancing.
Load balanacing se traduce mot a mot \^in balansarea \^inc\u arc\u aturii \c si const\u a \^in distribu\c tia cererilor 
c\u atre un server \^intre mai multe servere identice.Cea mai direct\u a metod\u a de scalare a unui server este 
multiplicarea lui.Nu este suficient s\u a avem mai multe servere identice \c si s\u a las\u am utilizatorii s\u a
decid\u a ce server doresc s\u a foloseasc\u a,a\c sa c\u a folosim un load balancer care s\u a decid\u a care dintre
copiile serverului s\u a proceseze fiecare cerere \^in func\ tie de un algoritm.Doar serverul de balansare 
\c stie de existen\c ta serverelor pe care le are \^in grij\u a.
\begin{figure}[!htb]
	\includegraphics[width=\textwidth,keepaspectratio]{LoadNotBalanced}
	\caption{Accesarea unui server}
	\label{fig:notLoadBalanced}
\end{figure}
\begin{figure}[!htb]
	\includegraphics[width=\textwidth,keepaspectratio]{LoadBalanced}
	\caption{Accesarea unui server prin intermediul unei load balancer}
	\label{fig:loadBalanced}
\end{figure}

A\c s fi putut s\u a nu accept \^inregistrarea mai multor servicii cu acela\c si nume \c si echilibrarea \^inc\u arc\u aturii 
de munc\u a s\u a fie f\u acut\u a de fiecare serviciu \^in parte iar aplica\c tia mea s\u a \^inregistreze doar acest server
dar dac\u a rezolv \c si responsabilitatea de balansare elimin un punct de e\c sec.Dac\u a toate serviciile care au nevoie 
de scalare folosesc un load balancer atunci func\c tionarea lor depinde de acesta.Elimin\u and nevoia existen\c tei a \^inc\u a
unui risc cre\c ste siguran\c ta.

\chapter{Tehnologii}

\section{.NET Framework}
.NET este o platform\u a de dezvoltare a software-ului gratuit\u a pentru diverse sisteme de operare.
Platforma include o bibliotec\u a de mari dimensiunii numit\u a Framework Class Library \c si permite interoperabilitatea
a multor limbaje de programare.Programele scrise \^in .NET Framework ruleaz\u a \^intr-un mediu numit
Common Language Runtime(CLR), o ma\c sin\u a virtual\u a de aplica\c tie care ofer\u a servicii precum
securitatea, managementul memoriei \c si tratarea excep\c tiilor.Biblioteca de clase \c si CLR formeaz\u ua 
.NET Framework.\footcite{wikidotNet}

\section{C\#}

C\# este un limbaj de programare modern, orientat pe obiecte \c si puternic tipizat.C\# \^i\c si are r\u ada\u 1cinile
\^in familia de limbaje C \c si le este imediat familiar programatorilor C,C++ sau Java.C\# are multe caracteristici care
ajut\u a la construc\c tia palica\c tilor  robuste \c si durabile:
\begin{itemize}
	\item Garbage Collector-ul elibereaz\u a automat memoria ocupat\u a de obiectele care nu mai sunt folosite.
	\item Tratarea excep\c tilor ofer\u a o abordare structurat\u a \c si extensibil\u a pentru detectarea 
	erorilor \c si recuperare
	\item Designul puternic tipizat care face imposibil\u a existen\c ta variablilelor neini\c tializate,
		indec\c silor \^in afara limitelor \c sirurilor sau convertirea neverificat\u a a tipurilor.
\end{itemize}
C\# are un sistem de unificat de tipuri.Toate tipurile din limbaj,incluz\^and primitivele precum int,
mo\c stenesc dintr-o singur\u a r\u ad\u acin\u a tipul object.De aceea toate tipurile au un set de 
opera\c tii \c si valori de orice tip pot fi stocate,transportate \c si folosite pentru opera\c tii
\^intr-un mod consistent.

Pentru a se asigura faptul c\u a programele \c si bibliotecile C\# pot evolua \^in timp intr-o manier\u a compatibil\u a,
s-a pus accent pe versionare \^in designul limbajului.Multe limbaje de programare nu acord\u a suficient\u a aten\c tie
version\u arii \c si de aceea programele scrise \^in acele limbaje crap\u a nejustificat de frecvent atunci c\u and sunt
introduse veriuni noi ale bibliotecilor de care programul depinde.Aspecte din limbajul C\# care au fost influen\c tate 
de aceast\u a decizie includ modificatorii \verb1virtual1 \c si \verb1override1,regulile de supra\^inc\u arcare 
ale metodelor \c si suportul pentru declarare explicit\u a a interfe\c telor membre.\footcite{Hejlsberg:2003:CLS:861332}

\section{Asp.NET}

ASP.NET este un framework open-source pentru dezvoltarea web.A fost dezvoltat de Microsoft pentru a
le permite programatorilor s\u a creeze site-uri si servicii web dinamice.A fost introdus odat\u a cu
.NET framework 1.0 \c si ca urmare este construit pe CLR,ceea ce permite programatorilor sa utilizeze cod
scris in oricare limbaj suportat de platform\u a.La \^incpeuturile sale, dezvoltarea web site-urilor Asp.NET
era asociat\u a cu WebForms, care datorit\u a limit\u arilor sale a fost \^inlocuit e Asp.NET MVC. 

\subsection{Asp.NET MVC}
Asp.NET MVC reprezint\u a o alternativ\u a la WebForms pentru construc\c tia aplica\c tilor web \^in cadrul
platformei .NET.Asp.NET MVC are o abordare diferit\u a \^in ceea ce prive\c ste structura aplica\c tiei, folosind
arhitectura MVC.
Asp.NET MVC este mai aproape de protocoloul HTTP.spre deosebire de Web Forms care \^incearca s\u a ascunda 
natura far\u a stare a protocolului.Folosind arhitectura MVC \c si asociind o singur\u a cerere HTTP apel\u arii 
unei metode, experien\c ta dezvoltatorilor este mai naturala.

\^In timp ce Web Forms are o str\^ans\u a leg\u atur\u a \^intre logica aplica\c tiei \c si interfa\c ta grafic\u a,
Asp.NET MVC \^incurajeaz\u a un design \^in care interfa\c ta grafic\u a(view-ul) este separat\u a de codul
care o conduce(controller-ul).Atunci c\^and acest design este implementat corect, aplica\c tia devine mult mai u\c sor de men\c tinut
\c si dezvolatat.
De asemenea aceast\u a separare face componentele aplica\c tiei s\u a fie mult mai u\c sor de testat \^in isolare,
ceea ce faciliteaz\u a testarea automat\u a.

Una din componentele centrale ale paginilor Asp.NET MVC este motorul Razor.Acesta ofer\u a un mode concis
de a combina cod C\# \c si marcaj HTML pentru a crea pagini dinamic.Razor este esen\c tial pentru a afi\c sa 
utilizatorului rezultatul cererilor sale.Cu ajutorul Razor aceea\c si pagin\u a poate fi diferit\u a pentru 
fiecare utilizator.

\subsection{MVC pattern}
Model View Controller(MVC) este un \c sablon arhitectural care prezint\u a o solu\c tie pentru tratarea interfe\c tei grafice.
Arhitectura MVC este una dintre cele mai frecvent \^int\^alnite arhitecturi \^in dezvoltarea aplica\c tiilor web, deoarece
contribuie la scalabilitatea si extensibilitatea proiectelor.Separarea explicit\u a a responsabilit\u at\c tilor
cre\c ste pu\c tin complexitatea designului aplica\c tiei,dar beneficiile eclipseaz\u a efortul extra.\footcite{proAspNetMVC5Pattern}
MVC separ\u a aplica\c tia \^in trei componente:
\begin{enumerate}
	\item \textbf{Model}

		Componenta model corespunde logicii legate de date \c si prelucrarea lor.Asta poate \^insemna
		datele care sunt transferate \^intre componentele view \c si controller sau orice alte date care \c tin de
		logica aplica\c tiei.
	\item \textbf{View}

		Componenta View este folosit\u a pentru toat\u a logica ce \c tine de logica \^ interfe\c tei.
		\^In cazul aplica\c tilor web, view-ul este un \c sablon dupa care este generat codul HTML.
	\item \textbf{Controller}

		Componenta Controller func\c tioneaz\u a ca o interfa\c ta \^intre componentele view \c si model.
		Aceast\u a comonent\u a r\u aspunde inputului utilizatorului,comunic\u a cu modelul \c si decide 
		care view trebuie folosit ca rezultat al cererii.
\end{enumerate}
\begin{figure}[!htb]
	\includegraphics[width=\textwidth,keepaspectratio]{MVCPattern}
	\caption{Arhitectur\u a MVC}
	\label{fig:MVCPattern}
\end{figure}
\subsection{Asp.NET WebApi}
Un web api este o interfa\c t\u a programatic\u a la un sistem care este accesat\u a prin metode standard HTTP.
Un web api poate fi accesat de o varietate larg\u a de clienti HTTP, incluz\^and browser \c si dispozitive mobile \footcite{evolvableWebApi}.

Asp.net MVC este construit cu scopul de a face website-uri.Acest lucru este evident din func\c tionarea acestui framework,
r\u aspunde la cereri primite din browser \c si returneaz\u a HTML.Cu toate acestea Asp.NET MVC permite un control minu\c tios
asupra r\u aspunsului dat,\c si MVC este util \^in formarea unui web api.Dezvoltatorii asp.net au realizat c\u a puteau folosi
acest framework pentru dezvoltarea de servicii web \c si aceasta improviza\c tie era preferabil\u a alternativelor.\footcite{proAspNetMVC5Asp}

Din acest motiv,odat\u a cu Asp.NET MVC 4,a fost introdus si Asp.net Web Api,un framework care ofer\u a 
stilul de lucru din Asp.NET MVC adaptat pentru a scrie servicii web.

\section{JavaScript}
JavaScript este un limbaj de programare interpretat cu capabilit\u a\c ti de orientare pe obiect.
JavaScript este sintactic similar cu C,Java \c si C\#,\^inc\u a similarit\u a\c tile se termina la sintax\u a.
JavaScript este un limbaj slab tipizat,ceea ce \^inseamn\u a c\u a variabilele nu au un tip specificat.
Obiectele asociaz\u a nume de propriet\u a\c ti unor valori arbitrare \c si se aseam\u n\u a mai mult
cu hashtable-urile din C\# dec\^at cu obiectele.Mecanismul de mo\c stenire din JavaScript este bazat pe
prototip \c si nu se aseam\u an\u a cu cea din C++ sau C\#.
Tipurile primive din JavaScript sunt numere,stringuri \c si valori booleene dar limbajul include \c si
date,\c siruri \c si expresii regulate.\footcite{Flanagan:2011:JDG:2029041}

Motivul principal pentru care am les s\u a folosesc acest limbaj \^in proiectul meu este faptul c\u a 
JavaScript este limbajul cunoscut de toate browser-ele \c si \^in acel context este extins cu obiecte care
permit interac\c tiunea cu utilizatorul, alterarea con\c tinutului paginii care 
este \^inc\u arcat\u a \^in browser \c si  controlul browser-ului.Aceast\u a versiune a limbajului
este numit\u a \c si JavaScript \verb1client-side1 pentru a sublinia faptul c\u a scripturile func\c tioneaz\u a
\^in browser-ul clientului \c si nu pe server.

De\c si JavaScript este utilizat predominant \^in dezvoltarea paginilor web,datorit\u a popularit\u a\c tii 
acestuia, s-au dezvoltat numeroase 
framework-uri dedicate acestui limbaj care permit dezvoltarea pe diferite platforme.
Cu Node.js JavaScript poate fi folosit pentru a face servere web.Electron.js permite ca JavaScript
s\u a fie folosit pentru aplica\c tii desktop cross-platform.JavaScript poate fi folosit \c si pentru
aplica\c tii pentru dispozitivele mobile prin intermediul frameworkurilor Ionic sau React.js. 

\section{HTML}

Hypertext Markup Language(HTML) este limbajul de marcaj standard pentru creearea paginilor web \c si aplica\c tiilor web.\footcite{wikiHTML}\^Impreun\u a cu 
CSS \c si JavaScript formeaz\u a cele trei limbaje esen\c tiale care definesc interfa\c ta grafic\u a a unei aplica\c tii web.
Navigatoarele web primesc documente HTML de la un server \c si pe baza acestuia afi\c seaz\u a o pagin\u a web.HTML descrie 
structura semantic\u a a unei pagini.

Elementele HTML sunt blocuri de construc\c tie ale paginilor HTML.Folosind HTML se pot introduce \^in pagini obiecte precum imaginile
sau form interactive se pot introduce \^intr-o pagin\u a web.De asemenea,HTML permite crearea unor documente structurate, denot\^and
structural semantice pentru text precum paragrafe, liste, linkuri, gilimele \c si altele.Elementele HTML sunt delimitate de taguri
scrise folosind paranteze unghiulare.Exist\u a taguri care introduc direct elemente, precum tagul <img/>.Pe de alt\u a
pare exist\u a \c si taguri care dau informa\c tii despre subelementele acestora, precum tagul <strong>.
Navigatoarele nu afi\c seaz\u a direct documentele HTML, ci stiu s\u a le interpreteze.Despre elementele 
HTML se pot da informa\c tii suplimentare prin atributele acestora.Majoritatea atributelor sunt perechi
de tip cheie valoare separate prin semnul "=".De asemenea valoarea atributelor trebuie specificat\u a \^intre ghilimele.
Atributele se g\u asesc mereu \^in tagul de \^inceput al elementelor HTML.

\section{CSS}

Cascading Style Sheets(CSS) este un limbaj de stil folosite pentru descrierea prezent\u arii documentelor scrise \^in HTML.
CSS a fost conceput pentru a permite separarea \^intre prezentare \c si con\c tinut, incluz\^and forme,culori \c si fonturi.
Aceast\u a separare poate \^imbun\u at\u a\c ti accesibilitatea con\c tinutului.De asemenea separarea permite mai mult\u a 
flexibilitate \c si control \^in specificarea caracteristicilor prezent\u arii.Un alt beneficiu pe care \^il aduce CSS este 
faptul c\u a mai multe pagini web pot folosi acelea\c si stiluri, dintr-un fi\c sier .css, ceea ce reduce complexitatea
\c si repetabilitatea.Mai mult,folosind acela\c si fi\c ier css putem  da un aspect similar paginilor care fac parte din 
aceea\c si aplica\c tie,cree\^and o unitate \^inte acestea.Numele cascading din CSS provine de la metoda pe prioritizare 
a stilurilor care afecteaz\u a un element.CSS folose\c ste prioritate de tip cascade pentru a determina regula de stil aplicat\u a 
unui element atunci c\^and acesta este afectat de mai mult reguli.CSS alege regula care va fi folosit\u a parcurg\^and \^in cascad\u a toate
regulile aplicate elementului pornind de la cea mai general\u a p\^an\u a la cea mai specific\u a. 

\^Inainte de CSS,HTML era folosit \c si pentru partea prezentare, motiv pentru care au ap\u arut foarte multe taguri HTML
cu rol de prezentare.HTML a fost conceput pentru a avea un rol structural \^in pagin\u a dar a devenit din ce \^in ce mai 
aglomerat cu taguri de prezentare\footcite{cssDef}.Aceast\u a poluare a limbajului a fost sesizat\u a \c si de c\u atre World Wide Web Consortium (W3C)
care au c\u autat o solu\c tie la problem\u a.Solu\c tia propus\u a de W3C a fost CSS care a devenit o recomandare cu aceea\c si greutate
ca HTML.De atunci CSS a evoluat odat\u a cu dezvoltarea web, p\^an\u a la starea \^in care se afl\u a ast\u azi.

\section{Entity Framework}
P\^ana la .NET 3.5,programatorii obi\c snuiau sa foloseasc\u a ADO.NET pentru a alva sau prelua date din 
baza de date.Trebuiau deschise conexiuni, create DataSeturi pentru a citi sau scrie date care mai apoi trebuiau 
convertite \^in obiect sau invers.Acesta era un proces greoi \c si predispus la erori.Odat\u a cu .NET 3.5
Microsoft a introdus EntityFramework cu scopul de automatiza lucrul cu baze date.

EntityFramework este un ORM(Object Relational Mapper) open-source creat de Microsoft pentru platforma .NET.
Framework-ul premite programatorilor s\u a utilizeze datele prin intermediul  unor obiecte specifice domeniului
far\u a a se concentra pe tabelele \c si coloanele \^in care datele sunt stocate.Acest lucru permite dezvoltatorilor 
s\u a lucreze la un nivel mai \^inalt de abstractizare atunci c\^ and lucreaz\u a cu date persistente.

EntityFramework ofer\u a dou\u a modalit\u a\c ti de lucru:
\begin{itemize}
	\item \textbf{Code First}

		Aceast\u a abordare necesit\u a ca programatorul s\u ascrie clasele corespunz\u atoare datelor care trebuie s\u a persiste \^in baza de date \c si 
		o clasa speciala numit\u a context.Pe baza acestora el poate genera o baz\u a de date.Baza de date generat\u a
		se poate actualiza prin migra\c tii.Migra\c tie ofer\u a un mode incremental de a aplica schimb\u ari unei baze
		de date generate cu EntityFramework pentru a o sincroniza pe aceasta cu clasele care consitiuie modelul. O migra\c tie
		con\c tine toate scimb\u arile modelului care trebuie reflectate \^in baza de date de la ultima actualizare.
		\^Impreun\u a toate migra\c tile formeaz\u a istoria bazei de date.

	\item \textbf{Database First}

		\^In aceast\u a abordare EntityFramework creaz\u a clasele model be baza unei baze de date deja existente printr-un proces numit
		scaffolding.Termenul scaffolding provine din domeniul construc\c tiilor \c si \^inseamna procesul de montare a schelelor unei cl\u adiri.
		Precum schelele fac posibil\u a construc\c tia unei cl\u adiri, a\c sa modelul face posibil\u a prelucrarea datelor din baza de date.
		Aceast\u a este abordarea pe care am decis s\u a o folosesc \^in realizarea acestui proiect.
	\item \textbf{Model First}
		Abordarea Model first presupune creare entit\u a\c tilor \c si rela\c tilor dintre acestea \^intr-o schem\u a,utiliz\^and un designer grafic.
		Pe baza schemei sunt generate clasele ce constituie modelul \c si baza de date.
\end{itemize} 
Din experien\c ta mea cu variantele prezentate, am ajus s\u a prefer varianta database first, deoarece consider c\u a astfel am mai mult control
asupra datelor \c si opera\c tiilor.

\section{Microsoft SQL Server}
Microsoft SQL Server este un sitem de management al bazelor de date rela\c tionale,care sus\c tine o varietate
larg\u a de aplica\c tii.Precum alte sisteme de management al bazelor de date relaz\c tionale,SQL Server
este construit peste SQL, un limbaj standardizat pe care administratorii de baze de date \c si profesioni\c stii IT
\^il folosesc pentru a manageria baze de date \c si pentru a interoga dateele pe care acestea le con\c tin.
SQL Server este legat de Transact-SQL, o Implementare a SQL de la Microsoft care adaug\u a un set de extensii 
de programare limbajului standard.
Componenta central\u a a SQL Server este motorul bazei de data,care controleaz\u a stocarea datelor, procesarea lor
\c si securitatea.Acesta include un motor rela\c tional care proceseaz\u a comenzi \c si interog\u ari \c si 
un motor de stocare ce manageriaz\u a fi\c sierele, tabele, paginile, indec\c si, buffer-ele de date \c si tranzac\c tile.
Procedurile stocate, trigger-ele,view-urile \c si celelalte obiecte ale bazei de date sunt de asemenea create \c si executate 
de motorul bazei de date.\footcite{sqlServer}
Mai jos dec\^at motorul bezei de date se alfa sistemul de operare al SQL Server(SQLOS) care se ocup\u a
de opera\c tii de nivel sc\u azut precum managementul memoriei \c si intr\u arilor \c si ie\c sirilor, programarea joburilor 
\c si blocarea datelor pentru a evita conflictele la actualizare.Deasupra motorului bazei de date se afla un strat de re\c tea,
care folose\c ste protocolul Tabular Data Stream al Microsoft pentru a facilita interac\c tiunile de tip cerere \c si r\u aspuns
cu serverul.

\chapter{Implementare}

\section{Arhitectura}

Aplica\c tia este construit\u a urm\^and o arhitectur\u a pe straturi.
\^in arhitectura pe straturi componentele apicla\c tiei sunt organizate \^in starturi orizontale,
fiecare \^indeplinind un rol specific \^in cadrul aplica\c tiei.Fiecare strat este o abstractizare 
a \^in jurul cerin\t elor aplica\c tiei.Una din tr\u as\u aturile definitorii ale acestei arhitecturi
este separarea responsabilit\u a\c tilor.Componentele unui strat al aplica\c tiei se procup\u a doar 
cu logica specific\u a stratului \c si nu se intersecteaz\u a cu logica altor straturi.
Nu exist\u a un num\u ar impus de straturi, \^in unele cazuri anumite straturi pot lipsi sau pot 
ap\u area noi straturi.

Serviciul meu de \^inregistrare este compus din 4 straturi, \c si anume:
\begin{enumerate}
	\item Un strat de stocare al datelor
	\item Un strat de accesare a date
	\item Un strat de logic\u a de business
	\item Un strat de prezentare
\end{enumerate}

\subsection{Stratul de stocare a datelor}

Acest strat const\u a \^in baza de date.
Pentru c\u a am folosit EntityFramework \^in modul Database First am \^inceput proiectul cu arhitecturii
bazei de date.Dac\u a \^in viitor vor ap\u area probleme de performan\c t\u a voi putea optimiza accesarea datelor
scriind prorpile proceduri stocate mai eficiente dec\^at cele generate de EntityFramework pe baza codului.
Pentru a putea interac\c tiona cu aplica\c tia prin interfa\c ta grafic\u a \^intr-un mod securizat este nevoie 
de un sitem de autentificare deci trebuie stocate date despre utilizator.Pentru autentificare fiecare utilizator
trebuie s\u a poate fi indentificat unic \c si din motive de securitate evindente el are nevoie de o parol\u a
a c\u arei valoare hash este stocat\u a \^in baza de date.Pentru partea de autorizare este nevoie ca fiec\u arui 
utilizator s\u a \^ii fie asociat unul sau mai multe roluri.\^In func\c tie de rolul unui utilizator,aplica\c tia decide
dac\u a acestui \^ii este permis accesul la o anumit\u a func\c tionalitate.Administratorul serviciului
va avea toate rolurile \c si ca urmare va avea acces nerestric\c tionat.\^In prezent  mai exist\u a un singur alt tip
de utilizator, al c\u arui singur nu rol \^ii permite s\u a fac\u a modific\u ari pe server.Acest rol este inte\c tionat
pentru programatorii care lucreaz\u a cu unul sau mai multe din serviciile \^inregistrate \c si le pune la dispozi\c tie 
informa\c tii legate de starea serviciilor.Sistemul de roluri este g\^andit \^in a\c sa fel \^inc\^at  s\u a fi u\c sor 
de ad\u augat \c si integrat un rol nou.Introducerea unui rol nou nu va afecta cu nimic rolurile existente \c si nici
utilizatorii existen\c ti.Rolurile pot fi asgnate \c si utilizatorilor vechi d\^andule astfel noi permisiuni.


Pentru ca utilizatorii s\u a aib\u a mai multe informa\c tii, am implementat un mecanism de mesagerie.Acesta nu este 
inten\c tionat ca un mijloc de comunicare \^intre utilizatori, ci este un mod ca ei s\u a fie informa\c ti de sistem.
Deoarece add-inurile au acces la mesaje, nu exist\u a o regul\u a cu privire trebuie s\u a cont\c tin\u a un mesaj.
Acestea pot con\c tine orice de la inform\u ari cu privire la servicii care nu au mai fost folosite de mult, p\^an\u a
la mesaje de \^in\^ampinare a unui nou utilizator.Dup\u a cum se vede \c si in Figura \ref{fig:DbUser}, un mesaj 
are un destinatar \c si un expiditor.Acest lucru poate fi folosit dac\u a pe viitor utilizatorii vor avea nevoie s\u a
 \^i\c si poat\u a trimite mesaje unul altuia, dar \^in prezen expeditorii mesajelor sunt add-inurile.
 Fiecare add-in are asociat un utilizator special f\u a\u a nici un rol.


\begin{figure}
	\includegraphics[width=\textwidth,keepaspectratio]{DbDiagramUsers}
	\caption{Diagrama rela\c tiilor utilizatorului}
	\label{fig:DbUser}
\end{figure}

Pentru un serviciu de \^integistrare cele mai importante date sunt cele referitoare la serviciile \^inregistrate.
Un serviciu este identificat prin numele de cluster \c si numele de aplica\c tie.Cluster-ul define\c ste grupul
din care face parte un serviciu.Nu exist\u a o restric\c tie de unicitate pentru combina\c tia nume de cluster \c si
nume de aplica\c tie, deoarece func\c tia de load balancing se func\c tioneaz\u a atunci c\^and exist\u a mai multe 
servere identice. Pentru a putea fi folosit,un serviciu are nevoie \c si de un URL.URL-ul trebuie s\u a fie unic \^in 
cadrul unui cluster.Nu are sens ca acela\c si serviciu s\u a fie \^inregistrat de dou\u a ori,\^ins\u a nu ar trebui 
s\u a fie oprit din a fi folosit \^in mai multe clustere, astfel URL-ul nu trebuie s\u a fie unic, ci combina\c tia 
cluster,URL. Dup\u a cum se poate observa \c si \^in figura \ref{fig:DbServices}, am ad\u augat un tabel destinat
monitoriz\u arii acces\u arii serviciilor.\^In etapa ini\c tial\u a a proiectului acest tabel era \^inlocuit de 
c\u atre o coloan\u a \^in tabelul Services care con\c tinea data ultimei acces\u ari a serviciului.De\c si 
data ultimei acces\u ari este o informa\c tie important\u a, nu este suficient\u a.Stoc\^and fiecare accesare 
pot realiza statistici relevante pentru utilizatori.

\begin{figure}[!ht]
	\includegraphics[width=\textwidth,keepaspectratio]{DbDiagramServices}
	\caption{Diagrama serviciilor}
	\label{fig:DbServices}
\end{figure}


\pagebreak

\subsection{Stratul de accesare a datelor}

Stratul de accesare a datelor const\u a \^intr-un proiect separat ce con\c tine interfe\c te \c si clase 
 care au responsabilitatea de a prelua sau prelucra datele din baza de date.Aceast\u a separare aduce numeroase
 beneficii:
 \begin{itemize}
	 \item Am eliminat duplicarea codului de acces la date.
	 \item Separearea responsabilit\u a\c tiilor cre\c ste mentenabilitatea \c si citibilitatea codului
	 \item Datorit\u a decupl\u arii am f\u acut codul testabil \^in izolare.Un alt avantaj
	 \item Am decuplat aplica\c tia de framework-ul de persisten\c t\u a, astfel este mai u\c soar\u a schimbarea
	 	acestuia dac\u a \^in viitor va ap\u area nevoia. 
 \end{itemize}
 
Accesarea datelor se face prin interfe\c te, a c\u aror implementare este ob\c tinut\u a prin injectare de dependen\c te
Am definit c\^ate o interfa\c t\u a pentru fiecare entitate persistent\u a major\u a.

Interfa\c ta IUserRepository con\c tine 
metode pentru accesarea datelor despre utilizatori, sau trimiterea mesajelor c\u atre utilizatori.Un mesaj poate fi trimis c\u atre 
un singur utilizator sau c\u atre to\c ti utilizatorii care \^indeplinesc o anumit\u a condi\c tie.Pentru a stabili o condi\c tie 
de trimitere c\u atre mai mul\c ti utilizator am folosit un delegat pentru o metod\u a ce prime\c ste ca parametru un obiect de tip 
User \c si returneaz\u a un r\u aspuns boolean.

Interfa\c ta IClusterRepository define\c ste metodele clasice ale unui repository, \c si anume opera\c tiile CRUD \c si o metod\u a de
filtrare folosind un delegat.

Interfa\c ta IServicesRepository este probabil cea mai important\u a, deoarce corespunde fun\c tionalit\u atii principale ale aplica\c tiei.
Este evident c\u a aceast\u a trebuie s\u a aib\u a metode pentru \^inregistrarea,de\^inregistrarea \c si g\u asirea serviciilor.
De asemenea este nevoie \c si de o metod\u a pentru a ob\c tine toate serviciile, astfel \^inc\^at acestea s\u a poat\u a fi 
afi\c sate \^in interfa\c ta grafic\u a.Tot pentru partea vizual\u a a aplica\c tiei am avut nevoie \c si de un mod de a aduce 
din baza de date toate acces\u arile unui serviciu dintr-un interval e timp.Pe baza dateloe de acces pot realiza staticstici referiotare
la accesul la servicii.

Tot \^in stratul de accesare a datelor se afl\u a \c si Interfa\c ta ILoadBalancer\ref{lst:ILoadBalancer}.Clasa ServicesRepository care implementeaz\u a
interfa\c ta IServicesRepository se folose\c ste de un obiect ce implementeaz\u a interfe\c ta ILoadBalancer, ca o strategie.
Strategia este un \c sablon de proiectare comportamental care permite schimbarea algoritmului \^in timpul rul\u arii aplia\c tiei.
Acest lucru se face trimi\c t\^and un obiect ce implementeaz\u a ILoadBalancer prin constructorul clasei ServicesRepository.
Pentru interfa\c ta ILoadBalancer am f\u acut \c si o implementare implicit\u a, care este folosit\u a \^in cazul \^in care nu exist\u a o implementare sub form\u a de 
add-in.Acest\u a implementare va returna url-ul serverului care a fost folosit \^in urma cu cea mai \^indelungat\u a perioad\u a \c si se potrive\c ste 
serviciului c\u autat.Parametrii clusterName \c si appName ai metodei GetService sunt folosi\c ti pentru a identifica serviciul,
iar  parametrul ipAddress reprezint\u a adresa ip a celui care solicitat serviciul respectiv.Adresa ip trebuie stocat\u a odat\u a
cu data acces\u arii serviciului.

\begin{lstlisting}[caption={Interfa\c ta ILoadBalancer},label={lst:ILoadBalancer}, breaklines]	
    /// <summary>
    ///     Strategy for load balancing algorithm
    /// </summary>
    public interface ILoadBalancer
    {
        /// <summary>
        ///  Get a service using a load balancing algortihm
        /// </summary>
        /// <param name="clusterName"></param>
        /// <param name="appName"></param>
        /// <param name="ipAddress"></param>
        /// <returns></returns>
        Service GetService(string clusterName, string appName, string ipAddress);
    }
\end{lstlisting}

\pagebreak

\subsection{Startul de logic\u a de business}

Startul  de logic\u a de business con\c tine 2 proiect.Un proiect dedicat Add-inurilot \c si unul dedicat utiliz\u arii 
datelor venite din stratul de acces al datelor.\^In acest proiect se g\u asesc trei interfe\c te \c si implement\u ariile lor.
Interfe\c telor IServicesRepository,IUserRepository \c si IClusterRepository  din stratul precedent,le corespunde o 
interfa\c t\u a \^in acest strat.Pentru IServicesRepository exist\u a IServicesManager,pentru IClusterRepository exist\u a 
IClusterManager \c si pentru IUserRepository exist\u a IUserManager.Implement\u arile interfe\c telor de tip manager se folosesc
de obiecte de ce implementeaz\u a interfe\c tele repository corespunz\u atoare pentru a accesa datele.Aceste obiecte sunt 
furnizate prin procedeul inject\u arii dependen\c telor.Astfel ServicesManager care  implementeaz\u a interfa\c ta 
IServicesManager, prime\c te o implementare a IServicesRepository prin care realizeaz\u a accesarea \c si prelucrarea datelor.
Folosind interfe\c te, managerii nu depind de modul \^in care datele sunt stocate.Metodele managerilor au rolul de a face 
valid\u arii asupra parametriilor cu are sunt apelate pentru a preveni caut\u ari inutile printre datele stocate sau
inserarea unor date are ar putea afeta consisten\c ta datelor stocate.Cu toate aceastea managerii nu se limiteaz\u a 
la valid\u ari,clasele repository doar aduc datele,tot resutl logicii se petrce \^in manageri.Se poate spune c\u a un repository
este o unealt\u a care \^ii d\u a acces la date unui manager.

\^In cel\u alalt proiect din acest strat se afl\u a logica ce guverneaz\u a add-inurile.Ca un add-in 
s\u a fie \^inc\u arcat \^in aplica\c tie acesta trebuie s\u a fie fac\u t cunoscut aplica\c tiei.
Acest lucru se face printr-un fisier de tip *.sAddIn care define\c ste add-inul.Fi\c sierele *.sAddIn sunt fi\c siere
\^in format JSON care conc\c tin informa\c tii despre addIn.Dup\u a  cum se vede \^in \ref{lst:addInDef}, defini\c tia 
unui add-in trebuie s\u a con\c tin\u a numele add-inului,o scurt\u a descriere,tipul de add-in, intervalul la care 
acesta trebuie executat \c si calea c\u atre add-in.Intervalul este exprimat \^in ore \c si este luat \^in considerare 
doar pentru add-inurile periodice.
loca\c tia de pe disc a add-inului. 
\begin{lstlisting}[caption={Defini\c tie a unui AddIn},label={lst:addInDef},breaklines]
{
	"Name":"UnusedServiceNotifier",
	"ShortDescription":"Sends a notification to the administrators regarding unused services",
	"Type":"Periodic",
	"RunInterval":4,
	"Path":"/AddIns/Periodic/USN.dll"
}
\end{lstlisting}
Pe l\^ang\u a un fis\c ier \^il define\c ste, pentru a putea fi executat un add-in trebuie s\u a con\c tin\u a o clas\u a 
ce implementeaz\u a Interfa\c ta IAddin.Aceast\u a clas\u a este punctul de intrare \^in add-in.

\^In prezent din punct de vedere al limbajului de programare folosit, add-inurile se \^impart in dou\u a categorii, \c si
anume add-inuri scrise \^in C\# \c si add-inuri scrise \^in CSScript.Add-inurile C\# sunt sub form\u a de dll iar 
cele scris \^in CSScript sunt fi\c siere text cu extensia .csscript.Problema \^in aceast\u a situa\c tie este c\u a 
ambele tipuri de add-inuri trebuie tratate la fel \^ins\u a este evident c\u a execu\c tia acestor se face diferit.
Bilbiotecile trebuie \^inc\u arcate \^in aplica\c tie apoi prin mecanismul reflection trebuie g\u asit\u a 
clasa ce implementeaz\u a interfa\c ta IAddin \c si apoi exceutat\u a metoda Run a acesteia.
Pe de alt\u a parte fi\c siere CSSript sunt fi\c siere text \c si acestea trebuie interpretate de un interpretor CSScript.
Interpretorul caut\u a punctul de intrare \^in add-in \c si apoi execut\u a metoda Run.Cu siguran\c t\u a nu pot \^In ciuda diferen\c tei dintre 
cele dou\u a tipuri de add-inuri, ele trebuie tratate similar de c\u atre aplica\c tie.
Am rezolvat o parte din problem\u a definind o interfa\c t\u a IAddInRunner care s\u a se ocupe de lansarea \^in execu\c tie 
a extensilor.Prin intermediul acesteia, procesul de ad\a ugare al unui nou tip de add-in se reduce la crearea unei noi
implement\u ari a interfe\c tei, potrivit\u a pentru tipul dorit.Nu doar c\u a am fac\u at posibil\u a implementarea add-inurilor
 sub forma de bibliotec\u a cu leg\u atur\u a dinamic\u a \c si sub form\u a de scrip CSScript, dar am \c si preg\u atit
 aplica\c tia pentru dezvoltare viitoare.Singur a problem\u a r\u amas\u a este faptul c\u a aplca\c tia are nevoie de un mod
 de a \c sti ce fel de add-inuri s\u a foloseasc\u a.Decizia cu privire la tipul de add-in se face dintr-un fi\c sier de 
 configurare.O posibil\u a solu\c tie ar fi ca la oric\^and este nevoie ca aplica\c tia s\u a stie ce fel de extensii trebuie 
 s\u a foloseas\u a, aceast\u a s\u a fac\u a o verificare.Aceast\u a abordare nu doar c\u a va polua codul cu interog\u ari
 \c si va cauza duplicare de cod, dar este \c si foarte greu de \^intre\c tinut \c si dezvoltat.Solu\c tia mea a fost
s\u a folosesc o implementare de tip abstract factory \ref{fig:IAddInRunnerFactory}.Abstract Factory este un \c sablon de proiectare care ofer\u a 
o interfa\c t\u a pentru creearea unei familii de obiecte \^inrudite sau dependente f\u ar\u a specificarea claselor
lor concrete.\footcite{Freeman:2004:HFD:1076324} 

\begin{figure}[!ht]
	\includegraphics[width=\textwidth,keepaspectratio]{IAddInRunnerFactory}
	\label{fig:IAddInRunnerFactory}
\end{figure}

\^In func\c tie de tipul de addIn specificat \^in fi\c sierul de configurare al serverului,se va alege care implementare a 
interfe\c tei IAddInRunnerFactory va fi folosit\u a de aplica\c tie.Implementarea aleas\u a va fi folosit\u a \^in \^intreaga
aplica\c tie  \c si astfel cu o singur\u a verificare programul va folosi tipul de add-inuri dorit.

Exist\u a situa\c tii \^in care un add-in devine irelevant sau nedorit de utilizator, din acest motiv,Add-Inurile trebuie 
s\u a poat\u a fi \c sterse de utilizator.Pentru a ad\u auga aceast\u a func\c tionalitate, am creat \c si implementat o
 interfa\c ta dedicat\u a st\u arii de pe disc a add-inurilor.Aceast\u a interfa\c t\u a poate reg\u asi add-inurile de pe disc
 \c si le poate \c sterge.

 Dup\u a cum am men\c tionat mai devreme exist\u a un tip de add-inuri care sunt executate periodic.Fiecare add-in de acest tip 
 are un alt interval orar la care trebuie executat.Cu scopul de a planifica \c si lansa \^in execu\c tie aceste add-inuri am f\u a cut
 clasa AddInScheduler.AddInScheduler opereaz\u a \^intr-un fir de execu\c tie separat datorit\u a naturii asincrone a acestuia.
  AddInScheduler se ocup\u a de lansarea \^in execu\c tie a tuturor add-inurilor ce trebuie executate periodic.
 Clasa ofer\u aposibilitatea ad\u aug\u arii unui add-in nou oric\^and \c si la dispari\c tia unui add-in de pe disc, AddInScheduler
 \^il va scoate automat din lista de excu\c tie.Din nou intervine problema lans\u arii \^in execu\c tie a add-inurilor,
 dar de data aceasta este \^in cadrul AddInScheduler.De\c si \^in cazul unei implement\u ari naive, execu\c tia add-inurilor
 de c\u atre AddInScheduler ar putea p\u area o problem\u a,defapt execu\c tia nu este treaba acestei clase.
 Tot ce trebuie s\u a fac\u a clasa AddInScheduler este s\u a foloseasc\u a o implementare a interfe\c tei IAddInRunner 
 care la r\^andul ei s\u a se ocupe de execu\c tia add-inurilor.\c Si dup\u a cum am stabilit anterior, AddInScheduler
 va ob\c tine o implementare corect\u a a IAddInRunner printr-un factory. 

\subsection{Stratul de prezentare}

La acest strat aplica\c tia se bifurc\u a form\^and dou\u a servere.Primul server este serviciul de \^inregistrare
care este component\u a principal\u a a proiectului meu.Acesta este un server de tip Web Api astfel interfa\c ta grafic\u a
\^int\^alnit\u a \^in mode obi\c snuit \^in stratul de prezentare este \^inlocuit\u a de o interfa\c t\u a de comunicare
cu serverul prin intermediul HTTP.Stratul de prezentare din webapi are o arhitectur\u a MVC \^in care lipse\c ste partea
de View.

Al doilea server este interfa\c ta grafic\u a a aplica\c tiei \c si permite administrarea aplica\c tiei.\^In cazul 
acestui server stratul de prezentare se reg\u ase\c ste \^in sensul clasic.Arhitectura stratului este MVC complet spre
deosebire de cazul anterior.

Toate starturile precedente sunt comune \^in cele dou\u a servere.
Separarea aplica\c tiei ini\c tiale \^in dou\u a servere distincte nu doar reduce munca fiec\u arui server,
dar \c si faciliteaz\u a dezvoltarea.

\section{Injectarea dependen\c telor}

Inte\c tia implement\u arii pe straturi este o cuplare mai slab\u a \^intre modulele aplica\c tiei.Acest lucru este 
realizat prin folosirea interfe\c telor \^in locul implement\u arilor concrete \c si prin injectarea dependen\c telor.
\^In Asp.NET MVC \c si Web Api toate cererile utilizatorilor sunt trimise c\u atre un Controller care se ocup\u a de
r\u astpunsul la acestea.Controller-ele sunt instan\c tiate de c\u atre framework ceea ce m\u a \^impideic\u a s\u a 
fac o injectare de dependen\c te clasic\u a.Asta nu \^inesamn\u a c\u a trebuie s\u a deteriorez  arhitectura, ci 
trebuie s\u a fac injectarea dependen\c telor printr-un alt mod.Abordarea alternativ\u a este oferit\u a de c\u atre 
Autofac.Autofac este un container pentru inversarea controlului.Cu autofac pot \^inregistra \^intr-un container 
implement\u arile interfe\c telor de care am nevoie \c si atunci c\^and va fi nevoie de o implementare, se va folosi tipul
\^inregistrat \^in container.De exemplu,c\^and se va crea o instan\c t\u a a clasei AccountController, care necesit\u a 
implement\u area interfe\c tei IUserManger,acesta va primi o nou\u a instan\c t\u a a clasei UserManager \c si pentru ca 
aceasta necesit\u a o implementare a IUserRepository, \c si UserManager va primi implementarea IUserRepository \^inregistrat\u a
\^in container.Cu autofac pot \^inregistra \c si tipuri \^in timpul rul\u arii, cum am f\u acut \^in cazul interfe\c tei 
ILoadBalancer, a c\u arei implementare se caut\u a \^intr-un add-in.


\section{Cur\u a\c tarea automat\u a}

Una dintre situa\c tile care pot cauza erori este situa\c tia \^in care un serviciu este inactiv.
Dac\u a acest serviciu este solicitat \c si serverul furnizeaz\u a acest serviciu aplica\c tie 
care a f\u acut cererea, cel mai probabil vor ap\u area erori \^in aplica\c tia respectiv\u a.
Serviciul d \^inregistrare trebuie s\u a fie c\^at mai de \^incredere.Acesta trebuie s\u a rezolve problemele
de conexiune \^intre aplica\c tii, nu s\u a le cauzeze.

Pentru a evita situa\c tia \^in care exist\u a servicii inactive, toate servicile trebuie monitorizate.
Serviciu de \^inregistrare trebuie s\u a \c stie mereu starea serviciilor pentru a evita trimiterea lor solicitan\c tilor.
Cu acest scop creat clasele din figura \ref{fig:MonitorDiagram}.Clasa ServicesCleaner are rolul de cur\u a\c tare a servicilor
inactive.Aceast\u a cur\u a\c tare presupune c\u a servicile inactive nu vor putea fi percepute ca servicii func\c tionale de 
c\u atre aplica\c tie.Cur\u a\c tarea propriuzis\u a este f\u acut\u a printr-o strategie.Strategia folosit\u a \^in prezent este 
RemovalCelaningStrategy, o implementare a ICleaningStrategy care elimin\u a din sistem  serviciile inactive.Pentru a avea acces la servicii, 
RemovalCelaningStrategy se folose\c ste de o implementare a IServicesManager despre care am discutat \^intr-o sec\c tiune anterioar\u a.
 ServicesCleaner folose\c ste
interfa\c ta IServicesMonitor pentru a c\u auta serviciile inactive.Interfa\c ta are o singur\u a metod\u a \c si anume GetInactiveServices 
care returneaz\u a o list\u a de servicii.Implementarea acestei interfe\c te se nume\c ste ServicesMonitor.Se ServicesMonitor se folose\c ste 
de o implementare a interfe\c tei IServicesManager pentru a extrage serviciile \^inregistrate din baza de date.Serviciile \^inregistrare 
sunt mai apoi verificate prin intermediul interfe\c tei IConnectionChecker.ConnectionChecker care implementeaz\u a IConnectionChecker,
\c si unica sa metod\u a, CheckConnection, \^incearc\u a s\u a trimit\u a un ping c\u atre un server \c si \^in func\c tie de
r\u aspunsul primit stabile\c ste dac\u a conexiunea la server se poate realiza.

ServicesCleaner are dou\u a metode publice, BeginCleanUp \c si StopCleanUp.BeginCleanUp semnaleaz\u a faptul c\u a obiectul trebuie
s\u a \^inceap\u a verificarea \c si cur\u a\c tarea serviciilor. Aceast\u a verificare este realizat\u a la un interval fix de timp,
specificat prin parametrul metodei BeginCleanUp. Intervalul de timp este transmis c\u atre obiectul Timer din al obiectului de tip 
ServicesCleaner.

\begin{figure}[!ht]
	\includegraphics[width=\textwidth,keepaspectratio]{MonitorDiagram}
	\label{fig:MonitorDiagram}
\end{figure}
Pentru a putea folosi


\section{Autentificarea \c si autorizarea}

\^In asp.net exist\u a un framework numit IdentityModel care se ocup\u a de o mare parte din autentificarea \c si autorizarea
utilizatorilor.Acesta se integreaz\u a bine cu framework-ul ASP.NET MVC \c si este suficient pentru securitatea majorit\u atii 
aplica\c tiilor.IdentityModel este de asemenea u\c sor de folosit \c si cu un efort minim o aplica\c tie poate avea partea de 
autentificare \c si autorizare func\c tional\u a.Din aceste motive este foarte comun \^in aplica\c tiile ASP.NET.

Cu toate aceste beneficii pe care le aduce, IdentityModel este un framework destul de restrictiv.Utilizarea acestul framework
ar fi presupus compromisuri \^in arhitectura pe care o doresc.IdentityModel se preteaz\u a cel mai bine pentru o arhitectur\u a
mai simpl\u a.IdentityModel necesit\u a acces direct la baza de date, ceea ce nu este valabil \^intr-o arhitectur\u a pe straturi
precum cea a aplica\c tiei mele.De asemenea framework-ul este g\^andit pentru a fi folosit cu EntityFramework \^intr-o abordare 
Code First.IdentityModel aduce cu el ni\c ste clase model \c si o clas\u a context, ceea ce \^in abordarea Code First simplific\u a
munca dezvoltatorului.Cum eu am ales aboradarea Database First, acest lucru este un impediment.Acest obstacol poate fi 
ocolit dac\u a generez baza de date \^intr-o alt\u a aplica\c tie, apoi copiez exact tabelele create de IdentityModel \^in 
baza de date a aplica\c tiei mele.Totu\c si chiar cu aceast\u a metod\u a de ocolire r\u am\^ane problema accesului direct
la baza de date.Din cauza restric\c tilor impuse de acest framework am ales s\u a renun\c t la acesta \c si s\u a \^imi fac 
propriul sistem de autentificare \c si autorizare pe care s\u a \^il integrez cu ASP.NET.

\begin{figure}[ht]
	\includegraphics[width=\textwidth,keepaspectratio]{LogIn}
	\label{fig:LogIn}
\end{figure}
Pentru a putea folosi aplica\c tia, utilizatorul trebuie s\u a se autentifice.Dac\u a acesta \^incerc\u a s\u a intre pe o pagin\u a a site-ului
de administrare f\u ar\u a s\u a fie atuentificat, va fi redirec\c tionat c\u atre pagina de autentificare\ref{fig:LogIn}.Autentificarea se face prin 
intermediul adresei de email \c si o parol\u a.Un utilizator nu \^i\c si poate crea un cont nou deoarece,serviciul 
de \^inregistrare nu este un serviciu public,acesta destinat utiliz\u arii \^in cadrul unei companii, doar de 
persoane autorizate.Din acest punct de vedere, serviciul este similar cu o re\c tea intranet.
Pentru comfortul utilizatorului, am ales s\u a folosesc pentru autentificare cookie-uri a\c sa \^inc\^at
utilizatorul s\u a nu fie nevoit s\u a se autentifice de fiecare dat\u a c\^and dore\c ste s\u a intre \^in
aplica\c tie.Termenul de expirare al cookie-ului am decis s\u a fie 30 de minute.Cookie-ul este creat imediat dup\u a ce 
utilizatorul s-a atuentificat cu succes.

Mecanismul de autorizare din ASP.NET se bazeaz\u a pe atributul AuthorizeAttribute . Acesta se poate aplica unei metode
sau unui controller, caz \^in care va afecta toate metodele acestuia.Defapt exist\u a dou\u a atribute AuthorizeAttribute ,
unul pentru ASP.NET MVC \c si unul pentru Web Api.Diferen\c tele \^intre ele sunt destul de mici \c si din punct de vedere al utiliz\u arii
sunt identice.Aceste atribute se folosesc de o interfa\c t\u a numit\u a IPrincipal\ref{lst:IPrincipal}, care reprezint\u a utilizatorul.Am creat o interfa\c t\u a nou\u a care mo\c stene\c ste 
interfa\c ta IPrincipal, care s\u a \^imi ofere o metod\u a de a accesa rolurile utilizatorului.Implementarea noii interfe\c te implementeaz\u a
\c si interfa\c ta IPrincipal, deci poate fi folosit\u a pentru autorizare de c\u atre atributul AuthorizeAttribute.Pentru 
controllerele de Web APi pot folosi AuthorizeAttribute  \c si nu mai este nevoie s\u a fac o clas\u a derivat\u a a acestuia.
Pentru controllerele ASP.NET MVC,deoarece atributul este diferit de\c si se numes\c te la fel ca cel din Web Api, am ales s\u a
fac un nou atribut care s\u a mo\c steneasc\u a AuthorizeAttribute.Noul atribut \c stie s\u a trateze situa\c tiile 
\^in care utilizatorul nu este autorizat \c si s\u a \^il redirec\c tioneze pe acesta c\u atre o pagin\u a potrivit\u a situa\c tiei \^in 
care se afl\u a.Dac\u a utilizatorul nu este autentificat, atunci va fi redirec\c tionat c\u atre pagina de autentificare.Dac\u a 
este autentificat dar nu ar permisiunea necesar\u a acces\u arii pagini respective va fi redirec\c tionat c\u atre o pagin\u a de eroare 
corespunz\u atoare.

\^In momentul \^in care un utilizator se \^incearc\u a s\u a se autentifice,din motive de securitate,se calculeaz\u a o valoare hash a parolei
introduse.Apoi se caut\u a un cont \^in baza de date cu acela\c i email ca cel introdus de utilizator, dac\u a un asemenea cont este g\u asit,
se compar\u a hash-ul nou cu hash-ul salvat \^in baza de date.Dac\u a \^in urma compara\c tia,se decide c\u a parola utilizatorului este gre\c sit\u a,el
va fi \^intros c\u atre pagina de autentificare.Dac\u a parola introdus\u a este corect\u a se creaz\u a un principal de care este criptat \c si 
introdus \^intr-un cookie.Dup\u a ce este setat\u a durata p\^an\u a la expirarea cookie-ului, acesta este trimis c\u atre utilizator.

Pentru ca atributele de autorizare s\u a aib\u a un IPrincipal corect, acesta trebuie extras din cookie.
\^In ASP.NET punctul de intrare \^in aplica\c tie este un fi\c sier numit Global.asax.cs \^in care se 
afl\u a clasa MvcApplication din care porne\c ste aplica\c tia.Aceast\u a clas\u a este derivat\u a din HttpApplication
\c si din acest motiv se pot schimba comportamente ale aplicac\c tiei prin suprascrierea 
unor metode mo\c stenite.Un dintre aceste metode este Application\_PostAuthenticateRequest, pe care am suprascris-o 
cu scopul de a extrage datele pentru IPrincipalul meu.Aici se caut\u a cookie-ul \c si dac\u a este 
g\u asit, se decripteaz\u a conc\c tinutul acestuia \c si se creaz\u a principalul corespunz\u ator 
utilizatorului autentificat.



\begin{lstlisting}[caption={Interfa\c ta IPrincipal},label={lst:IPrincipal},breaklines]
    //
    // Summary:
    //     Defines the basic functionality of a principal object.
    [ComVisible(true)]
    public interface IPrincipal
    {
        //
        // Summary:
        //     Gets the identity of the current principal.
        //
        // Returns:
        //     The System.Security.Principal.IIdentity object associated with the current principal.
        IIdentity Identity { get; }

        //
        // Summary:
        //     Determines whether the current principal belongs to the specified role.
        //
        // Parameters:
        //   role:
        //     The name of the role for which to check membership.
        //
        // Returns:
        //     true if the current principal is a member of the specified role; otherwise, false.
        bool IsInRole(string role);
    }
\end{lstlisting}

\section{Aspectul comun}

\^In aplica\c tia mea exist\u a c\^ateva elemente comune care trebuie s\u a apar\u a \^in fiecare pagin\u a.
Bara de naviga\c tie trebuie s\u a fac\u a parte din fiecare pagin\u a \^intruc\^at utilizatorul trebuie 
s\u a poat\u a schimba paginile site-ului cu u\c surin\c t\u a.Utilizatorul trebuie s\u a se poate 
deautentifica \c si ar fi absurd s\u a poate face asta doar dintr-o anumit\u a pagin\u a.Este mult mai 
convenabil pentru utilizator s\u a poat\u a vedea dac\u a are mesaje noi din orice pagin\u a,nu doar 
din pagina dedicat\u a.Pe l\^ang\u a acestea \c si func\c tionailatea de c\u autae ar fi bine s\u a fie accesibil\u a
de oriunde \^in aplica\c tie.Av\^and aceste tr\u as\u aturi comune pentru fiecare pagin\u a am nevoie de 
o metod\u a de implementare mai bun\u a dec\^at s\u a copiez partea comun\u a \^in fiecare pagin\u a.
Din fericire \^in ASP.NET exist\u a un tip de pagini numite pagini layout.Aceste pagini permit crearea 
unei pagini care are scopul de a aduna toate tr\u as\u aturile comune ale paginilor.Pagina layout nu este o pagin\u a de sine
st\u at\u atoare,ea trebuie folosit\u a \^impreun\u a cu o pagin\u a care s\u a con\c tin\u a partea specific\u a 
a paginii ce va fi prezentat\u a utilizatorului.\^In pagina layout se poate specifica exact locul \^in care pagina
ce folose\c ste aceaat\u a pagin\u a de aspect va ap\u area.Numele paginii de aspect trebuie s\u a \^inceap\u a cu \_.
Caracterul \_ este foarte important deoarece el \^in\c stiin\c teaz\u a framework-ul s\u a nu trimit\u a niciodat\u a
direct pagina layout. 

\begin{figure}[!htb]
	\includegraphics[width=\textwidth,keepaspectratio]{Layout}
	\label{fig:Layout}
\end{figure}

\begin{figure}[!htb]
	\includegraphics[width=\textwidth,keepaspectratio]{LayoutMinimized}
	\label{fig:LayoutMinimized}
\end{figure}

\^In cardul aplica\c tiei mele, am introdus \^in pagina de aspect,elementele comune ale tuturor paginilor \ref{fig:Layout}.
Pagina are o bar\u a de naviga\c tie, mimizabil\u a care poate trimite utilizatorul la pagina de management a
serviciilor, la pagina de management a add-inurilor sau la pagina de introducere a unui nou serviciu.
Bara de naviga\c tie se afl\u a \^in parrte din st\^anga a paginii.Butonul din josul barei reduce dimensiunea
acesteia.Interfa\c ta grafic\u a este receptiv\u a,incluz\^and bara de naviga\c tie. C\^and ecranul este prea mic
bara va fi \^inlocuit\u a de un buton. La ap\u asarea butonului va ap\u area con\c tinutul barei de naviga\c tie
ca \^in imaginea \ref{fig:LayoutMinimized}.

Butonul Logout deschide o fereastr\u a modal\u a care cere confimarea utilizatorului pentru a preveni,
ie\c sira din aplica\c tie neinten\c tionat\u a.Dac\u a utilizatorul confirm\u a deautentificarea,
sesiunea sa va fi distrus\u a \c si data de expirare a cookie-ului s\u au va fi redus\u a \^in a\c sa fel
\^inc\^at cookie-ul s\u a fie expirat la ie\c sirea din aplica\c tie.

Dupa\u acum se vede \c si \^in figura \ref{fig:Layout} l\^ang\u a butonul Logout se afl\u a o bar\u a de 
c\u autare.Aceast\u a bar\u a est folosit\u a pentru a c\u auta servicii sau clustere \^intregistrare \^in 
aplica\c tie.Dup\u a ce utilizatorul a scris numele sau o parte a numelui serviciului sau cluster-ului c\u autat,
c\^and va ap\u asa butonul de c\u autare, va fi trimis c\u atre o pagin\u a ce con\c tine rezultatul c\u aut\u arii
sale.Dac\u a nu exist\u a nimic care s\u a se potriveasc\u a cu ce a c\u autat el, \^in pagin\u a va fi afi\c sat un mesaj
de informare.

\^In st\^ anga barei de c\u autare se afl\u a un buton cu semnul unui colpot.La click pe buton va ap\u area
o fereastr\u a \^in care apar ultimele mesaje primite de utilizator \c si un buton.Mesajele sunt caracterizate 
prin subiect, con\c tinut, expeditor \c si data expedierii.Butonul de sub mesaje duce utilizatorul c\u atre o 
pagin\u a \^in care acesta poate vedea toate mesajele pe care le-a primit.

\^In ASP.NET MVC fiec\u arei pagini \^ii corespunde un model.Nu exist\u a nici o restric\c tie de unicitate
pe modele, mai multe pagini pot folosi acela\c si model.Dac\u a modelul este folosit doar pentru pagini,
atunci acesta este numit viewmodel, deoarece este specific view-ului aplica\c tiei.Modelul unei pagini 
este folosit prin intermediul Razor pentru a genera pagina html care este trimis\u a \^in final utilizatorului
site-ului.

Pentru c\u a sunt date care sunt comune pentru toate paginile, acestea ar fi bine s\u a fac\u a parte dintr-un
viewmodel.Solu\c tia mea la aceast\u a problem\u a a fost crearea unei clase BaseViewModel care con\c tine informa\c tiile 
comune.Toate celelalte viewmodel-e deriv\u a din clasa BaseViewModel \c si pagina de aspect se folose\c ste de clasa
de baz\u a pentru a-\c si lua datele necesare.

\^In ASP.NET fi\c sierele de stiluri CSS \c si fi\c sierele de scripturi JavaScript pot fi grupate \^in ni\c ste 
pachete numite bundle.Aceast\u a grupare se face \^intr-io clas\u a BundleConfig,care este apelat\u a din clasa 
MVCApplication care reprezint\u a punctul de intrare \^in aplica\c tie.Motivul pentru care este mai bine ca aceste fi\c siere s\u a fie trimise \^impreun\u a 
este c\u a este mai reapid s\u a fi trimise unitar c\u atre client dec\^at separat.\^In pagina layout a aplica\c tiei 
mele am setat un  bundle de fi\c siere CSS \c si unul de fi\c siere JavaScript care sunt folosite de c\u atre toate paginile
site-ului.

Fi\c sierul CSS con\c tine defini\c tii pentru mai multe clase folosite \^in aplica\c tie. Am ales s\u a organizez 
partea de prezentare \^in clase CSS deoarece mi se pare cel mai flexibil mod de prezentare a elementelor HTML.
Un element poate avea multiple clase ceea \c si fiecare poate descrie un aspect diferit as elementului.
Spre exemplu un element poate avea \^In acela\c si timp clasa dark \c si clasa sm-margin. Clasa dark seteaz\u a culoare fundalului \c si culoarea
textului din element. Clasa sm-margin adaug\u a o margine mic\u a elemntului. Elementul nu este limitat la numai dou\u a clase \c si 
acesta va lua propriet\u a\c ti din toate clasele sale. Consider c\u a origanizarea stilurilor pe clase este superioar\u a
set\u arii propriet\u a\c tilor unui element dup\u a id, deoarece clasele sunt reutilizabile. De asemenea 
cred c\u a utilizarea claselor este superioar\u a set\u arii propriet\u a\c tiilor tuturor elementrlor de un anumit 
tip deoarece exist\u a numeroase stitu\c tii \^in care nu dorim ca toate elementele de aclea\c si tip s\u a fie tratate la fel.
\^In pagina de management al serviciilor din Figura \ref{fig:AllServices}, at\^at cluster-ele c\^at \c si 
serviciile sunt elemente de tip li, dar acestea arat\u a foarte diferit.  De asemenea clasele pot afecta 
mai multe tipuri de elemente HTML. Folosind clasa button putem prezenta \c si un button simplu, \c si un submit 
al unui form \c si un link. De\c si aceastea sunt elemente diferite, se poate s\u a aib\u a roluri similar
\c si astfel s\u a dorim ca acestea s\u a arate la fel.

Tot pe baza claselor pot schimba comporamentul elementelor prin cod JavaScript. De exemplu,
atunci c\^and documentul este preg\u atit, toate elementele cu clasa btn-run-addin vor avea 
evenimentul de click setat. Atunci c\^and utilizatorul va face cick pe aceste elemente, printr-o cerere 
de tip GET la controller-ul AddInsApiController, se va lansa \^in execut\c tie un add-in.

Fi\c sierele mele JavaScript sunt f\u acute dupa un \c sablon de proiectare numit Module Pattern. Module Pattern 
este probabil cel mai comun \c sablon de proiectare din  JavaScript.Acesta \^incearc\u a s\u a iimite clasele din limbaje de programare 
orientate pe obiecte precum C\# sau C++. De\c si nu putem avea toate beneficiile program\u arii orientate pe obiecte, 
folosind acest \c sablon putem avea o \^incapsulare, return\^and din modul doar ceea ce este public.
Func\c tile care adaug\u a comportament la elemetele HTML, fac parte din ni\c ste module care 
se adaug\u a la un obiect principal. Acest obiect con\c tine o metod\u a pentru fiecare fi\c sier 
\c si acestea sunt apelate prin intermediul acestuia doar atunci c\^and documentul HTML este complet \^incarcat, \^impreun\u a cu
toate fi\c sierele JavaScript.

Singura pagin\u a din site care nu folose\c ste aspectul comun este pagina de autentificare, deoarece toate 
func\c tionalit\u a\c tile comune, necesit\u a ca utilizatorul s\u a fie autentificat.

\section{Managementul serviciilor}

Una dintre cele mai importante pagini din aplica\c tie este pagina de management a
serviciilor, care se poate vedea \^in figura \ref{fig:AllServices}.\^In aceast\u a pagin\u a
administratorul serviciului de \^inregistrare poate observa toate serviciile \^inregistrate,
organizate \^in clusterele din care acestea fac parte.Ini\c tial toate clusterele sunt expandate, \^ins\u a
acestea pot fi minimizate.Dac\u a utilizatorul va da click pe numele sau \^in zona gri din jurul numelui cluster-ului,
serviciile care apar\c tin clusterului se vor \^indrepta c\u atre acesta p\^an\u a ce vor disp\u area.
Utilizatorul poate accesa cluster-ele 
pentru a le vedea activitatea mai \^in detaliu,sau poate accesa un serviciu pentru 
a-i monitoriza activitatea.De asemenea el poate \c sterge servicii din server, sau chiar
clustere \^intregi.Pentru a efectua o opera\c tie de \c stegere, utilizatorului i se cere 
confirmarea printr-un alert al browser-ului. \c Stergerea se face printr-un apel ajax c\u atre o metod\u a 
a cotroller-ului ServicesApiController. 
\^In momentul \^in se prime\c ste un r\u aspuns pozitiv de la server serviciul respectiv este \c sters \c si din pagin\u a
prin javascript. \^In cazul \^in care r\u aspunsul primit este negativ se afi\c seaz\u a un mesaj de tip alert\u a.


\begin{figure}[!htb]
	\includegraphics[width=\textwidth,keepaspectratio]{AllServices}
	\label{fig:AllServices}
\end{figure}

\section{Managementul cluster-elor}

Aplica\c tia include \c si o pagin\u a dedicat\u a cluster-elor.\^in aceast\u a pagin\u a se afl\u a 
un grafic al activit\u a\c tii serviciilor membre al cluster-ului ca \^in figura \ref{fig:ClusterDetails}.Sub grafic se  
alf\u a lista serviciilor care fac parte din cluster, caracterizate prin numele de aplica\c tie, 
numele cluster-ului, adresa serviciului \c si data ultimei sale acces\u ari.
\^In dreptul fiec\u arui serviciu din cluster se afl\u a 2 butoane. Un buton \^indreapt\u a utilizatorul spre pagina 
dedicat\u a serviciului respectiv \c si un buton \c sterge serviciul. \^In realitate butonul de navigare c\u atre pagina 
serviciului, nu este un element HTML de tip buton ci este un element de tip link. Diferen\c ta nu es observ\u a deoarece
acest buton \c si butonul de \c stergere folosesc clase CSS similare.

Graficul este f\u acut \^in JavaScript, folosind biblioteca
Chart.js.Prin controller poate returna o pagin\u a care folosind Razor,transform\u a 
datele din viewmodel-ul pagini \^in structuri de date care pot fi folosite 
din cod JavaScript.Pentru ca un obiect C\# s\u a fie folosibil \^in cod JavaScript, acesta trebuie 
serializat \^in formatul JSON.Prin Razor folosesc cod C\# pentru a serializa obiectul din viewmodel care corespunde datelor 
care vor defini graficul. Motivul pentru care pot folosi obeictul serializat este faptul c\u a codul C\# este executat \^inainte ca 
pagina s\u a fie trimis\u a c\u atre utilizator. Codul JavaScript este interpretat de c\u atre browser-ul utilizatorului, deci 
se execut\u a dup\u a ce s- a f\u acut serializare.\^In browser va ap\u area rezultatul serializ\u arii care fiind \^in format JSON,
va fi interpretat exact ca crearea unui obiect JavaScript.

Pentru repartizarea culorilor corespunz\u atoare serviciilor reprezentate pe grafic am f\u acut un alogritm,
care genereaz\u a un num\u ar dorit de culori distincte.Culorile rezultate nu sunt doar distincte ca ton, ci 
sunt \c si vizibil diferite.Pentru un num\u ar mic de culori diferen\c ta \^intre acestea va fi foarte mare dar se 
va reduce odat\u a cu cre\c stere num\u arului de culori necesare.Algoritmul este scris \^in JavaScript deoarece 
cosider c\u a at\^ata timp c\^at nu reprezint\u a un risc de securitate este preferabil ca ma\c sina clientului 
s\u a efectueae c\^at mai mult din munca necesare. Cu c\^at mai mult\u a procesare este efectuat\u a de c\u atre client,
cu at\^at mai mult pot reduce \^inc\u arc\u atura server-ului.  

\begin{figure}[!htb]
	\includegraphics[width=\textwidth,keepaspectratio]{ClusterDetails}
	\label{fig:ClusterDetails}
\end{figure}

\section{Monitorizarea unui serviciu}

Am considerat ca fiind de interes activitatea unui serviciu \^inregistrat \^in program,
ceea ce m-a determinat s\u a fac o pagin\u a dedicat\u a monitoriz\u arii unui serviciu.
Dup\u a cum se vede \c si in exemplul din Figura  \ref{fig:ServiceDetails}, pagina con\c tine un 
grafic al activit\u a\c tii serviciului \^intr-un interval de timp precum \c si toate 
acces\u arile serviciului.Graficul poate fi minimizat ca \^in pagina de management a cluster-elor,\^intruc\^at nu am dorit s\u a ocup prea 
mult din ecranul utilizatorului dac\u a acesta este interesat la momentul respectiv de 
cererile f\u acute.Sub reprezentarea grafic\u a s afl\u a o list\u a cu fiecare accesare
a serviciului din intervalul de timp selectat.Pentru fiecare accesare se cunoa\c ste 
adresa ip de provenien\c t\u a a cererii \c si data la care aceasta a fost f\u acut\u a. 


\begin{figure}[!htb]
	\caption{Pagina de management a unui serviciu}
	\includegraphics[width=\textwidth,keepaspectratio]{ServiceDetails}
	\label{fig:ServiceDetails}
	\caption{Pagina de management a unui serviciu \^ in care graficul este minimizat}
	\includegraphics[width=\textwidth,keepaspectratio]{ServiceDetailsCollapsed}
	
\end{figure}


\section{Introducerea serviciilor}

De\c si serviciile ar trebui s\u a se \^inregistreze singure, \^in cazul \^in care se dore\c ste utilizarea unui
serviciu de provenien\c t\u a extern\u a, se pot introduce servicii manual prin intermediul interfe\c tei grafice.
Dup\u a cum se vede \^in figura \ref{fig:AddService},pentru a ad\u auga un serviciu este nevoie s\u a se introduc\u a
numele de aplica\c tie cu care acesta va fi \^inregistrat, numele cluster-ului din care acesta face parte \c si adresa 
serviciului.Numele cluster-ului se poate alege dintr-o list\u a ce con\c tine cluster-ele existente sau se poate introduce un
cluster nou.La ap\u asarea butonului "Congirm" cererea este trimis\u a c\u atre server \c si serviciul este \^inregistrat.
Dac\u a \^inregistrarea e\c sueaz\u a, utilizatorul va fi \^in\c stiin\c tat.

\begin{figure}[!htb]
	\caption{Pagina ad\u augare a unui serviciu}
	\includegraphics[width=\textwidth,keepaspectratio]{AddService}
	\label{fig:AddService}
\end{figure}

\section{Tratarea errorilor}

Func\c tionarea serviciului de \^inregistrare este critic\u a deoarece mai multe 
aplica\c tii se bazeaz\u a pe acesta.Din cauza rolului important pe care serviciul
\^il are, acesta trebuie s\u a fie c\^at mai robust.Prima problem\u a care poate  
ap\u area const\u a \^in cererile primite cu parametrii gre\c si\c ti sau cu scop
mali\c tiios.Fiecare ac\c tiune a aplica\c tiei trebuie s\u a \c stie s\u a returneze
un r\u aspuns adecvat, fie el mesaj de eroare, o pagin\u a web sau ni\c ste date.
Decizia r\u aspunsului \^in cazul \^in care o cerere e\c sueaz\u a se bazeaz\u a pe tipul
de excep\c tie primit \^in metodele controllerului.
Dac\u a pe parcursul proces\u arii cererii venite prin controller nu apare nici o 
excep\c tie sau apar doar excep\c tii din care aplica\c tia \^i\c si revine cu succes,
cererea va primi r\u aspunsul dorit.\^In caz contrar depinde de tipul de cerere f\u acut\u a.
Dac\u a utilizatorul \^incearc\u a s\u a acceseze o pagin\u a a site-ului f\u ar\u a a fi
autentificat, acesta va fi redirec\c tionat c\u atre pagina de autentificare.
Dac\u a se \^incearc\u a accesarea unei pagini la care utilizatorul nu are acces, acesta 
va fi redirec\c tionat la o pagin\u a de eroare care \^ii va explica situa\c tia \^in care 
se afl\u a.\^In ceea ce prive\c ste parte de Web API,unde r\u aspunsul nu este sub form\u a 
de pagin\u a web,utilizatorul care a f\u acut o cerere eronat\u a va primi un cod de 
r\u aspuns de eroare,Bad Request sau Not Found.
Am ales s\u a nu dau mai multe detalii despre eroare, din cauz\u a problemelor de securitate
care pot fi cauzate de aceste informa\c tii.O persoan\u a r\u au inten\c tionat\u a ar putea 
profita de informa\c tiile suplimentare pentru a produce daune serverului.
Bine\^inteles toate excep\c tile care apar pe parcursul derul\u arii aplica\c tiei,
sunt salvate \^intr-un fi\c sier de tip log.

\section{Componente}

\subsection{NuGet}

NuGet est un manager de pachete gratuit \c si open-source creat pentru platforma .NET.Acesta a fost creat \^in 2010
\c si de atunci a devenit din ce \^in ce mai popular.Datorit\u a u\c surin\c tei cu care se pot aduce \^in proiect 
pachete externe, \c si posibilit\u a\c ti de publicare a acelor pachete, NuGet a devenit omniprezent \^in 
dezvoltarea aplica\c tiilor \^in cadrul platformei .NET.NuGet faciliteaz\u a dezvolatrea at\^at .NET Framework
c\^at \c si \^in .NET Core.NuGet este \c si mecanismul de \^imp\u ar\c tit cod sprijinit de Microsoft.
NuGet este distribuit ca o extensie de Visual Studio care \^incep\^and cu Visual Studio 2012 vine preinstalat\u a
\^in IDE.Popularitatea NuGet a condus la integrarea sa complet\u a \^in Visual Studio,\^in Visual Studio 2017 pe 
l\^ang\u a managementul pachetelor, NuGet poate fi folosit direct din IDE pentru \^impachetarea bibliotecilor
de clase.

%cum se face 
% ce bine e integrat
%un pachet e un zip
\subsection{Registry Connector}

Am dorit ca serviciu de \^inregistrare s\u a fie c\^at mai u\c sor de utilizat.
Cu acest scop am creat dou\u a biblioteci care simplific\u a interac\c tiunea cu 
serverul.Mai mult,ca utilizatorii s\u a poat\u a beneficia de biblioteci c\^at mai 
u\c sor, am decis s\u a distribui aceste biblioteci sub forma unor pachete NuGet.
NuGet permite setarea surselor de pachete.NuGet se poate configura s\u a foloseasc\u a
mai multe servere pe post de surse.Pachetele mele ar trebui s\u a se afle pe un server 
privat, pentru a fi consumat intern \^in compania care folose\c ste serviciul de \^inregistrare.

Prima bibliotec\u a,IRegistryConnector ofer\u a un mod simplu de utilizare al serviciului.
Serviciul expune o interfa\c t\u a prin intermediul c\u areia utiliziatorul poate
cere url-ul pentru un anumit serviciu.Interfa\c ta are dou\u a metode, una pentru ob\c tinerea
adresei unui serviciu \c si una pentru re\^improsp\u atarea cache-ului.
Deoarece implementarea RegistryConnector folose\c ste un mecanism de caching bazat pe un fi\c sier,
aceast\u a clas\u a trebuie s\u a fie sigur\u a din punct de vedere al lucrului
cu fire de execu\c tie.Dac\u a acela\c si fi\c sier este folosit din dou\u a fire de execu\c tie 
diferite pot ap\u area erori.Problemele apar atunci c\^and sunt scrise date \^in fi\c sier,
iar citirea simutan\u a nu este o problem\u a.Implementarea mea blocheaz\u a opera\c tiile 
ce folosesc fi\c sierul, dac\u a un alt fir de execu\c tie scrie \^in fi\c sier \^in acel moment.
Dup\u a ce se termin\u a scrierea \^in fi\c sier, se poate opera din nou pe fi\c sier.
Mul\c tumit\u a sistemului de caching cre\c ste viteza de execu\c tie a programului pentru
c\u a nu mai este nevoie de o cerere c\u atre server.Mai important este faptul c\u a
av\^and un cache local scade dependen\c ta aplica\c tie de serviciul de \^inregistrare.
Un alt beneficiu, de data aceasta pentru server, este c\u a serverul nu mai este at\^at de 
solicitat.

\subsection{Registry Manager}

A doua component\u a pe care am f\u acut-o este destinat\u a serverlor care vor s\u a se 
\^inregistreze \^in serviciul de \^inregstrare.Componenta con\c tine on interfa\c t\u a,
care permite \^inregistrarea \c si de\^inregistrarea serviciilor.


\section{Testare}

Este evident c\u a cel mai important lucru la un program este ca acesta s\u a fie func\c tional.
Singurulul mod \^in care func\c tionarea acestuia poate fi asigurat\u a este testarea programului.
Testarea trebuie f\u acut\u a la fiecare modificare a aplica\c tie.De\c si modificarea nu afecteaz\u a
direct alte func\c tionalit\u a\c ti ale aplica\c tie, exist\u a totu\c si riscul ca indirect s\u a afecteze
alte module. Genul acesta de schimb\u ari nea\c steptate sunt unul din motivele pentru care o aplica\c tie
trebuie testat\u a frecvent. Cu c\^at calitatea codului este mai ridicat\u a cu at\^at mai putin se vor 
petrece schimb\u ari nea\c steptate, \^ins\u a indiferent c\^at de sigur a\c s putea fi de modific\u arile 
pe care le fac \c si de consecin\c tele acetora, lipsa test\u arii este un risc care ar trebui evitat.
Testarea manual\u a este necesar\u a \c si uneori nu poate fi evitat\u a, dar aceasta consum\u a mult timp.
Din acest motiv am ales s\u a automatizez procesul de testare scriind test automate.

Am ales s\u a folosesc framework-ul NUnit pentru testarea automat\u a din cadrul proiectului meu.
NUnit este un framework de testare open source pentru limbajele platformei .NET. NUnit a pornit ca 
o portare a JUnit, \^ins\u a versiunea curent\u a ,NUnit 3, este rescris\u a complet. Odat\u a cu 
aceast\u a rescriere, au fost ad\u augate \c si caracteristici noi \c si suport pentru mai multe platforme .NET.
Folosind NUnit am putut s\u a scriu teste automate cu care s\u a testez componentele aplica\c tiei \^in izolare.

Tot pentru testele automate am folosit biblioteca Moq. Aceast\u a bibliotec\ a \^imi permite crearea unor implement\u ari
de tip mock a interfe\c telor necesare test\u arii unei clase. De multe ori clasele testate depind de alte clase sau 
interfe\c te dar c\^and test\u am o clas\u a \^in izolare este de preferat ca clasa respectiv\u a s\u a nu aib\u a depende\c te.
Cu acest scop se folosesc implement\u arile mock ale interfe\c telor de care clasele depind. Cuv\^antul mock provine din
englez\u a \c si se poate traduce \^in iimita\c tie. Implement\u arile mock ale interfe\c telor sunt practic ni\c ste iimita\c tii 
utile doar pentru testare. Acestea sunt mai u\c sor de implemntat \c si au fun\c tionalit\u a\c ti ajut\u atoare.
De exemplu \^intr-o implementare mock se poate verifica de c\^ate ori a fost apelat\u a o metod\u a sau se pot executa 
ac\c tiuni dup\u a apelarea unei metode astfel implementate. Tot cu Moq putem face ca implement\u arile unor s\u a se comporte diferit 
\^in fun\c tie de parametrii primi\c ti sau s\u a se comporte indentic indiferent de parametrii.

Testele automate \^incurajeaz\u a un design cu o cuplare c\^at mai slab\u a \^intre componente deoarece \^in
caz contrar acestea nu mai pot fi testate \^in izolare. De exemplu, dac\u a \^in loc s\u a structurez aplica\c tia pe 
straturi a\c s fi avut toat\u a logica aplica\c tiei \^intr-un singur strat deja codul ar deveni mai dificil de testat.
Mai mult, dac\u a fiecare cerere pe care serverul poate primi ar fi tratat\u a \^in metoda corespunz\u atoare din controller,
atunci pentru o metod\u a din controller ar trebuie f\u acut c\^ate un test pentru fiecare screnariu.
Astfel s-ar ajunge la un num\u ar mare de teste din ce \^in ce mai complexe \^in fun\c tie de c\^at e departe \^in execu\c tia metodei 
va ajunge testul. Pe l\^ang\u a acest\u a problem\u a, pentru multe din testele f\u acute va fi nevoie ca testele s\u a fac\u a 
o conexiune cu baza de date ceea ce nu doar \^incetine\c ste viteza de execu\c tie a testelor dar \c si cre\c ste posibiliatea de 
e\c sec a unui test din cauze externe. Cu c\^at testele depind mai mult de alte resurse este mai probabil ca un test s\u a pice 
din alte motive dec\^at dintr-o problem\u a codului testat ceea ce scade relevan\c ta testelor. Testarea individual\u a \^in izolare, ajut\u a 
la identificarea problemelor \^in cod, deoarece astfel se \c stie exact componenta \^in care se afl\u a o problem\u a.
Av\^and la dispozi\c tie suita de teste pe care am scris-o, oric\^and doresc pot detecta dac\u a modific\u arile 
pe care le fac func\c tioneaz\u a corect. Pentru o astfel de verificare am nevoie de mai pu\c tin de un minut.
Bine\^inteles acest\u a siguran\c ta pe care o am legat\u a de func\c tionarea aplica\c tiei este limitat\u a
de scenarile acoperite de teste. \^Intr-o situa\c tie ideal\u a \^in care tot codul ar fi acoperit complet de teste,
acestea ar fi suficiente pentru a asigura func\c tionarea corect\u a a \^intregii aplica\c tii. 


\subsection{Test Driven Development}


\begin{figure}[ht]
	\caption{Procesul de dezvoltare TDD}
	\includegraphics[width=\textwidth,keepaspectratio]{TDDProcess}
	\label{fig:TDDProcess}
\end{figure}

Pentru o parte a dezvolt\u arii am lucrat urm\^ and un proces numit test driven development(TDD).
Acest proces se bazeaz\u a pe repetarea unui scurt ciclu de dezvoltare. Primul pas al ciclului
presupune scrierea unui test automat p\^an\u a \^in punctul \^in care codul testat pic\u a testul respectiv.
Dac\u a codul testului nu poate fi compilat, atunci se consider\u a c\u a testul este picat. Acest lucru se \^int\^ampl\u a
de exemplu atunci c\^and \^intr-un scenariu de test se folose\c ste o metod\u a care \^inc\u a nu exist\u a.
\^In pasul al doilea se scrie suficient din codul testat \^inc\^at testul s\u a fie trecut, dar nu mai mult de at\^at.
Mai exist\u a un pas \^in care se face o refactorizare a codului pentru eliminarea redunda\c telor.
Robert C. Martin a definit 3 legi ale TDD \footcite{Martin:2011:CCC:1999258} menite s\u a-i men\c tin\u a pe practican\c tii 
aceste discripline \^intr-un ciclu de aproximativ 30 de secunde:
\begin{enumerate}
	\item Nu este permis\u a scrierea codulului de produ\c tie \^inaintea scrierea unui test pe care codul s\u a \^il 
	pice.
	\item Nu este permis\u a scrierea a mai mult dintr-un test dec\^at este suficient pentru ca testul s\u a e\c sueze.
	\item Nu este permis\u a scrierea a mai mult cod de produ\c tie dec\^at este necesar pentru ca testul corespunz\u ator 
	s\u a fie trecut. 
\end{enumerate}

Una dintre clasele pe care le-am f\u acut practic\^and TDD este clasa ServicesManager.
Spre exemplu, am creat metoda GetService din clasa ServicesManager \^incep\^and cu testul GetServiceFoundTest \ref{lst:GetServiceTest}
care testeaz\u a metoda GetUrl din ServicesManager.
\c Stiind c\u a clasa manager se folose\c ste de o interfa\c t\u a IServicesRepository, a trebuit s\u a \^incep testul f\u ac\^and 
un mock pentru interfa\c ta respectiv\u a. Implementarea mock va returna un obiect de tip Service specific atunci c\^and 
metoda GetService va fi apelat\u a cu parametrii specifica\c ti. Mai apoi instan\c tiez un obiect de tip ServicesManager c\u aruia i-am pasat 
prin construnctor instan\c ta implement\u arii mock a interfe\c tei IServicesRepository.
Compilarea codului e\c sueaz\u a deorarece nu exist\u a clasa ServicesManager.
Din acest moment am trecut la partea urm\u atoare a ciclului, \^in care am \^inceput s\u a scriu clasa.
Din momentul \^in care am f\u acut constructorul cu parametru m-am \^intors la codul testului.
Am \^inceput cu verificarea rezultatului metodei pe care o doresc s\c i din nou compilarea se va \^incheia cu e\c sec.
Atunci a fost momentul s\u a creez metoda GetUrl \c si s\u a implementez fun\c tionalitatea care returneaz\u a 
url-ul corect din repository.
\^In final am verificat ca metoda GetService s\u a fi fost apelat\u a.

\begin{lstlisting}[caption={Testul pentru metoda },label={lst:GetServiceTest},breaklines]
    [Test]
        [Category("GetService")]
        public void GetServiceFoundTest()
        {
			const string LOCALHOST = "127.0.0.1";
            Mock<IServicesRepository> mockRepository = new Mock<IServicesRepository>();
            mockRepository.Setup(t => t.GetService("app", "cluster", LOCALHOST)).Returns(new Service() { AppName = "app", Cluster = new Cluster { Name="cluster" }, Url = "url" })
                .Verifiable();
            ServicesManager manager = new ServicesManager(mockRepository.Object);
            Assert.AreEqual("url", manager.GetUrl("app", "cluster", LOCALHOST));
            mockRepository.Verify();
        }
\end{lstlisting}


\chapter{Utilizare}

Serviciul de \^inregistrare \c si site-ul de management al acestuia sunt menite s\u a simplifice dezvolatarea 
\c si utilizarea microserviciilor. Din acest motiv ele trebuie s\u a fie disponibile dezvoltatorilor acestor 
microservicii. Aceast\u a apical\c tie nu este destinat\u a unui public larg, ci est g\^andit\u a pentru a fi folosit\u a
intern \^intr-o companie. Doar membrii autoriza\c ti ai acestei companii au acces la site-ul de management, dar 
probabil to\c ti cei care sunt implica\c ti \^in dezvoltarea microserviciilor au acces la serviciu de \^inregistrare.

Primul lucru de care este nevoie pentru func\c tionarea srviciului de \^inregistrare \c si a site-ului este baza de date.
Pentru asta este nevoie \^in primul r\^and e un sistem de gestiune al bazelor de date Microsoft SQL Server.
Cel mai probabil acesta va fi pe un server separat de aplica\c tii, deci trebuie ca cel ce face instalarea 
s\u a se asigure c\u a serverul pe care se afl\u a baza de date poate fi accesat de c\u atre celelalte servere.
Creare efectiv\u a a bazei de date pe server se poate face cu u\c surin\c t\u a folosind scripturile SQL pe care le-am
f\u acut cu acest scop. Dup\u a ce baza de date a fost creat\u a \c si este fun\c tional\u a, trebuie create conturile 
utilizatorilor serverului. Acestea trebuie create printr-un script de c\u atre o person\u a autorizat\u a.
Din moment ce serviciul de \^inregistrare este privat, conturile nu trebuie s\u a poat\u a fi create de oricine.
Dac\u a conturile are putea fi f\u acute de c\u atre oricine, securitatea serverului ar putea fi compromis\u a.
 
Dup\u a ce baza de date func\c tioneaz\u a \c si conturile au fost create, trebuie instalat serviciul de \^inregistrare.
Acesta trebuie instalat primul deoarece f\u ar\u a acesta, interfa\c ta de management este inutil\u a, ne av\^and obiectul muncii
sale. Dup\u a ce  serviciul de \^inregistrare func\ ctioneaz\u a, se poate face instalarea site-ului de management al 
serviciului.

Nu este important unde este instalat\u a aplica\c tia. Aceasta se poate afla pe Azure, pe un server intern sau se poate
folosi orice serviciu de g\u azduire. Cu toate acestea poate ar fi mai bine ca serverul de management s\u a fie \^intr-o
re\c tea de tip intranet. Site-ul nu este nevoie s\u a fie accesibil din afara companiei \c si acest lucru ar 
putea \^imbun\u at\u a\c ti securitatea.

Dac\u a utilizatorii serviciului de \^inregistrare pl\u anuiesc s\u a dezvolte aplica\c tii \^in C\#,
atunci ar fi cel mai bine s\u a se foloseasc\u a d componentele de NuGet pe care le-am f\u acut.
Acestea ar trebui distribuite folosind un server NuGet privat care s\u a apar\c tin\u a companiei.
Folosind un server NuGet este mai u\c sor pentru utilizatori s\u a actualizeze componentele \^in momentul 
\^in care apar noi versiuni. Astfel de modific\u ari pot ap\u area atunci c\^and se schimb\u a modul de utilizare 
al serverului. Dac\u a vor ap\u area noi m\u asuri de securitate \^in contactarea serviciului de \^inregistrare,
componentele va trebui actualizate pentru a suporta schim\u arile de pe server. Dac\u a nu se poate folosi 
un Server de NuGet, exist\u a dou\u a solu\c tii alternative. A solu\c tie este crearea unui director \^in care s\u a se afle toate versiunile 
componentelor \c si utilizarea directorului ca un depozit NuGet local. O alt\u a solu\c tie, mai primitiv\u a 
este utilizarea direct\u a fi\c sierului dll din pachetul NuGet.

\section{Serviciul de \^inregistrare}

Serviciul de \^inregistrare este menit pentru a fi utilizat de c\u atre alte aplica\c tii, nu de c\u atre persoane.
Acesta se utilizeaz\u a prin metode HTTP. Pentru ob\c tinerea adresei unui serviciu \^intregistrat, \c si de\^inregistrarea
 se folose\c ste metoda GET, pentru \^inregistrarea unui serviciu se folose\c ste put.
\^Inregistrarea unui serviciu prin acest mod ar trebui f\u acut\u a de c\u atre serviciul care dores\c ste 
s\u a fie \^inregistrat. Dac\u a se dore\c ste \^intregistrarea unui serviciu \^in alt mod, atunci este recomandat\u a 
folosirea site-ului de management al serviciului de \^inregistrare.
De\^intregistrarea unui serviciu trebuie f\u acut\u a de c\u atre serviciul care s-a \^inregistrat. Dac\u a 
se \^incearc\u a \c stregerea unui serviciu de la alt\u a adres\u a ip dec\^at cea de la care acesta a fost \^inregistrat,
atunci aceast\u a \^incercare va e\c sua. Am ales acest comportament din motive de securitate, posibilitatea de 
a \c sterge servicii din orice loc este o vulnerabilitate care are premite unui atacator s\u a \c stearg\u a 
servicii necesare \c si astfel s\u a opreasc\u a func\ tionarea unor aplica\c tii care necesit\u a serviciul respectiv.
De\c si un serviciu nu poate fi de\^inregistrat prin metoda prezentat\u a anterior din alte servere dec\^at cel care a 
f\u acut \^integistrarea, asta nu \^inseamn\u a c\u a un serviciu poate s\u a r\u aman\u a ve\c snic \^inregistrat.
Dac\u a serviciul devine inactiv acesta va fi \c sters automat de c\u atre serviciul de \^inregistrare.
Dac\u a se dore\c ste eliminarea unui seviciu de\c si acesta func\c tioneaz\u a, acest lucur se poate realiza prin 
interfa\c ta grafica a site-ului de management.  

Comportamentul serviciului de \^inregistrare poate fi modificat printr-un add-in.
Acesta este un add-in diferit de restul add-inurilor pe care aplica\c tia le accept\u a.
Acest add-in are rolul de a implementa un algoritm de echilibrare a \^inc\u arc\u aturii(load balancing).
Odat\u a \^inc\u arcat \^in aplica\c tie add-inul va fi folosit pentru aducerea serviciilor din
baza de date. Scopul acestui add-in este de a reduce \^inc\u arc\u atura unui singur 
serviciul de un anumit tip, distribuid cererile \^intre toate serviciile de acela\c si tip.
Bine\^inteles acest add-in nu este util \^in cazul \^in care exist\u a doar c\^ate un singur 
serviciu de un anume tip.

\section{Interfa\c ta grafic\u a a servicului de \^inregistrare}

Interfa\c ta grafic\u a a servicului de \^inregistrare se afl\u a pe un server separat de serviciu.
Prin intermediul acestei interfe\c te grafice se poaet monitoriza activitatea serviciului \c si se poate intera\c tiona 
cu acesta. \^Interfa\c ta grafic\u a a serviciului const\u a \^intr-un site f\u acut \^in ASP.NET MVC. 

Primul pas 
necesar pentru interac\c tionarea cu serverul const\u a \^in autentificarea utilizatorului. Autentificarea utilizatorilor 
se face pe baza conturilor men\c tionate \^in sec\c tiunea anterioar\u a. Autentificarea necesit\u a adresa de email 
\c si parola utuilizatorului dup\u a cum se poate observa \^in imaginea \ref{fig:LogIn} de la pagina \pageref{fig:LogIn}.  
Pasul de autentificare este obligatoriu \c si dac\u a utilizatorii \^incearc\u a accesarea oric\u arei alte pagini ale 
site-ului f\u ar\u a ca \^inainte s\u a treac\u a prin pasul de autentificare, ace\c stia vor fi redirec\c tion\c ti 
c\u atre pagina de autentificare.

Dup\u a ce autentificarea este reu\c sit\u a utilizatorul ete redirec\c tionat c\u atre pagina pe care se reg\u asesc toate 
servicile. Dac\u a utilizatorul a \^incercat s\u a acceseze o pagin\u a f\u ar\u a s\u a fie autentificat \c si a fost redirec\c tionat
c\u atre pagina de autentificare, dup\u a autentificare va fi redirec\c tionat c\u atre pagina pe care a \^incercat s\u a
o acceseze.

Pagina implicit\u a la care utilizatorul este trimis dup\u a autentificare este pagina din imaginea \ref{fig:AllServices} de la 
pagina \pageref{fig:AllServices}, prin care se poate interac\c tiona cu toate serviciile. Am ales acest\u a pagin\u a ca pagin\u a 
deoarece aceasta este pagina care ofer\u a privirea cea mai general\u a asupra serviciilor. pe l\^ang\u a prezentarea unei priviri de ansamblu 
asupra servicilor, tot prin aceat\u a pagin\u a se poate interac\c tiona cu serviciile \^inregistrate. Prin intermediul paginii
se pot \c sterge at\^at clustere c\^at \c si servicii individuale. De asemenea aceast\u a pagin\u a ofer\u a \c si un punct de 
acces c\u atre paginile dedicate clusterelor sau serviciilor.

Pagina dedicat\u a unui cluster informeaz\u a utilizatorul cu privire la activitatea serviciilor din cluster dintr-un interval de timp.
Dup\u a cum se poate observa \c si pe exemplul din imaginea \ref{fig:ClusterDetails} de la pagina \pageref{fig:ClusterDetails},
activitatea serviciilor este reprezentat\u a \^intr-un grafic. \^In grafic fiecare serviciu este reprezentat printr-o
culoare distinct\u a \c si reprezint\u a activitatea serviciilor dup\u a num\u arul de acces\u ari din fiecare zi.
Graficul poate fi minimizat \^in cazul \^in car utilizatorul este mai interesat de lista serviciilor, afi\c sat\u a 
sub grafic. Serviciile reprezentate \^in list\u a pot fi \c sterse cluster prin butonul 'Remove Service'. De asemenea 
prin butonul vecin, 'Details' se poate trece la pagina dedicat\u a serviciului respectiv. 

Prin intermediul paginii pe care sunt afi\c aste toate serviciile \c si al paginii dedicate unui cluster, se poate 
accesa pagina din figura \ref{fig:ServiceDetails} de la pagina \pageref{fig:ServiceDetails}. Aceast\u a pagin\u a
este dedicat\u a unui serviciu \c si ofer\u a mai multe detalii despre activitatea acestora. Utilizatorul poate 
vedea activitatea serviciului dintr-un intervat e timp selectat de el. Activitatea serviciului este reprezentat\u a 
printr-un grafic. La fel ca \^in cazul graficului din pagina activit\u a\c tii unui cluster, \c si acest graficul 
de pe aceast\u a pagin\u a este minimizabil. Sub grafic se afl\u a o list\u a cu toate datele \^in care serviciul 
a fost accesat \c si adresa ip de la care a fost accesat.

\^In st\^anga paginii se afl\u a bara de naviga\c tie a site-ului. Acest\u a bar\u a se afl\u a \^in fiecare pagin\u a a site-ului
\c si poate fi minimizat\u a de c\u atre utilizator dac\u a acesta dore\c ste mai mult pa\c tiu pentru pagina accesat\u a.
Bara de naviga\c tie reprezint\u a modul de schimbare a paginilor aplica\c tiei. Dac\u a ecranul utilizatorului nu este destul de 
\^inc\u apator, bara de naviga\c tie se schimb\u a \^intr-un buton \^in partea din st\^anga sus a ecranului ca \^in imaginea 
\ref{fig:LayoutMinimized} de la pagina \pageref{fig:LayoutMinimized}.

Interfa\c ta grafic\u a permite \c si ad\u augarea de servicii noi, nu doar \c stergerea celor deja existente.
Introducerea noilor servicii se face prin pagina din figura \ref{fig:AddService} de la pagina \pageref{fig:AddService}.
Aceast\u a pagin\u a poate fi accesat\u a prin intermediul barei de naviga\c tie.
Pentru a ad\u auga un nou serviciu trebuie completate toate c\^ampurile din formularul de pe pagin\u a, mai exact 
numele aplica\c tiei \^inregistrate, numele cluster-ului din care va face parte \c si adresa la care se g\u ase\c ste acesta.
C\^ampul \^in care trebuie completat ofer\u a o list\u a cu toate clusterele deja existente din care utilizatorul poate 
alege, dar permite \c si introducere unui cluster nou.

A treia pagin\u a care poate fi accesat\u a prin intermediul barei denaviga\c tie este pagina de management a add-inurilor.
Aceast\u a pagin\u a ofer\u a utilizatorului informa\c tii despre add-inurile \^inc\u arcate \^in aplic\c tie \c si 
posibilitatea posibilitatea de a interac\c tiona cu acestea. O astfel de intera\c tiune este \^nl\u aturarea acestora
prin intermediul unui buton, la ap\u asarea c\u aruia, utilizatorul este rugat s\u a \^i\c si confirme decizia.
Pentru add-inurile active, exist\u a un buton care permite lansarea acestora \^in execu\c tie.

Add-inurile sunt un mod avansat \^in care utilizatorii pot interac\c itona cu aplica\c tia. Ace\c stia 
pot pot decide s\u a extind\u a chiar ei aplica\c tia prin add-inuri. Utilizatorii pot extinde aplica\c tia 
f\u ar\u a s\u a aib\u a acces la codul surs\u a al acesteia. Le-am pus la dispozi\c tie utilizatoilor libertatea de a extinde 
aplica\c tia dup\u a nevoia \c si preferin\c tele lor. Aplica\c tia va \^inc\u arca add-inurile pe baza unor 
fi\c siere cu extensia .sAddIn care descriu add-inul care trebuie \^inc\u arcat.

Pe l\^ang\u a bara ed naviga\c tie mai exist\u a \c si alte elemente comune 
tututor paginilor site-ului. Un astfel de element const\u a \^in butonul Logout 
prin care utilizatorul se poate deautentifica. Dup\u a ap\u asarea acestuia 
utilizatorul autentificat trebuie s\u a confirme op\c tiunea sa printr-o 
fereastr\u a de confirmare.

Un alt element pe care toate paginile \^il con\c tine este bara de c\u autare.
Aici utilizatorul poate scrie numele sau pentre din numele unui serviciu sau cluster.
Dup\u a ap\u asarea butonului de c\u autare, utilizatorului i se va prezenta o pagin\u a 
\^in care poate vedea rezultatele c\u aut\u arii sale. Din pagina cu rezultatele 
utilizatorul poate naviga c\u atre pagina corespunz\u atoare rezultatului.
Dac\u a nu este g\u asit nici un rezultat la cererea de c\u autare a utilizatorului,
acesta va fi \^in\c stiin\c tat.

L\^ang\u a bara de c\u autare se afl\u a un buton de mesaje. La ap\u asarea acestui buton,
se va deschide o fereastr\u a \^in care vor ap\u area mesajele pe care utilizatorul 
autentificat le-a primit.De asemenea \^in acest\u a fereastr\u a exist\u a un buton care 
duce la o pagin\u a \^in care sunt afi\c sate toate mesaje primite de c\u atre utilizator.
Utilizatorii nu pot trimite mesaje, acestea pot fi trimise doar de c\u atre aplica\c tie sau de 
c\u atre add-inuri.

\chapter{Planuri de viitor}

\section{Securitatea}

Poate cel mai important lucru care trebuie avut \^in vedere atunci c\^and se pune problema  
dezvolt\u arii viitoare a aplica\c tiei este securitatea. Serviciul de \^inregistrare 
poate fi considerat un punct sensibil \^in func\c tionarea multor aplica\c tii, nu pentru c\u a 
ar fi mai vulnerabil ca alte servicii, ci pentru c\u a de func\c tionarea corect\u a a acestuia 
depind mai multe aplica\c tii. Dac\u a un server specific unei aplica\c tii \^i\c si va \^intrerupe 
activitatea, acea aplifa\c tie va avea de suferit, dar dac\u a serviciul de \^inregistrare este inactiv 
atunci se poate ca zeci de aplica\c tii s\u a aib\u a de suferit. 

De exemplu, \^in cazul unui
magazin online care folose\c ste o arhitectur\u a orientat\u a pe microservicii, dac\u a
serviciul de plat\u a devine inactiv, utilizatorii nu vor mai putea finaliza comenzile lor, \^ins\u a
aces\c stia nu vor fi oprit\c ti din a beneficia de restul site-ului. Utilizatorii vor putea p\u astra 
produsele dorite \^in co\c si \c si vor da comanda la o alt\u a data. Nefunc\c tionarea 
serviciului de plat\u a va fi o inconvenien\c t\u a dar nu va dobor\^a \^intreg site-ul.

Pe de alt\u a parte dac\u a magazinul ar folosi serviciul de \^inregistrare \c si acesta ar ceda,
ar \^inceta \^intreaga activitate a site-ului. Acest\u a problem\u a poate fi atenuat\u a \^in cazul 
\^in care exist\u a un sitem de caching pentru rezultatele primite de la serviciul de \^inregistrare.
Depende\c ta servicilor de serviciul de \^inregistrare face ca securitatea acestuia s\u a fie 
o prioritate \^in dezvoltarea sa.

\^In momentul de fa\c t\u a am implmentat c\^ateva m\u asuri de securitate. Una dintre aceste 
m\u asuri const\u a \^in procedurile de autentificare \c si autorizare ale site-ului de management 
al serviciului de \^inregistrare. De\^inregistrarea servicilor este probabil opera\c tia care are 
cel mai multe nevoie de securitate deoarece acest\u a opera\c tie poate opri \^intreaga fun\c tionare 
a serverului. Un atacator al serviciului ar putea \c sterge toate servicile din server \c si astfel 
oprind fun\c tionarea tuturor aplica\c tilor care utilizeaz\u a serviciul de \^inregistrare.
Pentru a preveni aceast tip de atac am restric\c tionat de\^inregistrarea serviciilor.
Prin verificarea adresei ip, doar serviciul care a f\u acut \^inregistrarea poate face de\^inregistrarea.

O alt\u a m\u asur\u a de securitate pe care am implementat-o este utilizarea certificatelor pentru 
\^inregistrarea sau \c stergerea serviciilor de pe server. Servicile care sunt autorizate s\u a se \^inregistreze 
ar vor avea un certificat \c si pe baza acestuia, serverul le va accepta sau refuza cererea.
De\c si implementarea pentru acest mecanism a fost f\u acut\u a, \^in momentul de fa\c t\u a
ea nu este folosit\u a. Aceast\u a metod\u a de autorizare re ar putea reprezenta o alternativ\u a la restric\c tionarea 
celor care pot face de\^inregistrarea.

Pe l\^ang\u a m\u asurile de securitat pe care le-am prezentat treuie s\u a m\u a sigur c\u a nu exist\u a
alte vulnerabilit\u a\c ti exploatabile \^in aplica\c tie. \^In sensul acesta, va trebui s\u a folosesc 
un scanner de vulnerabilit\u a\c ti. Imediat dup\u a descoperirea vulnerabilit\u a\c tilor va trebui s\u a 
\^incep eliminarea acestora.

\section{Testarea }

Un alt obiectiv pe care va trebui s\u a \^il am \^in vedere este testarea automat\u a.
De\c si am \^inceput scrierea testelor automate, acestea nu sunt \^inc\u a suficiente pentru 
a asigura func\c tionarea complet\u a aplica\c tiei conform a\c stept\u arilor mele.
Ca urmare este nevoie s\u a cresc num\u arul testelor p\^an\u a \^in punctul \^in care 
codul meu va avea o acoperire de aproape 100\% .

De\c si scrierea tutror testelor necesare 
se va \^intinde pe o perioad\u a \^indelungat\u a, pe termen lung voi putea economisi mult timp
care ar fi consumat de testarea manual\u a a tuturor scenarilor de utilizare. Mai mult,
testele vor reduce timpul petrecut \^in debug deoarece vor oferi o localizare destul de specific\u a
a erorilor. 

\section{Adaptarea}

Pe m\u asur\u a ce aplica\c tia va fi folosit\u a de c\u atre utilizatori, 
vor ap\u area \c si noi cerin\c te. Este inevitabil ca utilizatorii 
s\u a aib\u a propuneri referitoare la caracteristici pe care le doresc 
\^in aplica\c tie. Astfel eu va trebuie s\u a m\u a conformez cu noile 
cerin\c te pe care le voi aduna de la utilizatori. Prin arhitectura aplic\c tie 
am \^incercat s\u a anticipez schimb\u arile. Decizile pe care le-am luat pe parcusrul 
implement\u arii  fac dezvoltarea acestora 
c\^at mai u\c soar\u a.

\printbibliography

\end{document}

idei:
bootstrap
HTML
css
jquery
autofac
ce e un cookie